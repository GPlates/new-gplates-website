

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Primer &mdash; pygplates 1.0.0-rc.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="_static/theme_overrides.css?v=78492a5e" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=4b0c7688"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Sample code" href="pygplates_sample_code.html" />
    <link rel="prev" title="Getting started" href="pygplates_getting_started.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            pygplates
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="pygplates_introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="pygplates_getting_started.html">Getting started</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Primer</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#plate-reconstruction-hierarchy">Plate reconstruction hierarchy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#working-with-finite-rotations">Working with finite rotations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#composing-finite-rotations">Composing finite rotations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plate-circuit-paths">Plate circuit paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equivalent-total-rotation">Equivalent total rotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relative-total-rotation">Relative total rotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#equivalent-stage-rotation">Equivalent stage rotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#relative-stage-rotation">Relative stage rotation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#topologies">Topologies</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#topological-model">Topological model</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#topological-snapshot">Topological snapshot</a></li>
<li class="toctree-l4"><a class="reference internal" href="#topologically-reconstruct-geometries">Topologically reconstruct geometries</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#deformation">Deformation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#topological-network">Topological network</a></li>
<li class="toctree-l3"><a class="reference internal" href="#rigid-blocks">Rigid blocks</a></li>
<li class="toctree-l3"><a class="reference internal" href="#network-triangulation">Network triangulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#strain-rates-in-triangulation">Strain rates in triangulation</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#strain-rate-clamping">Strain rate clamping</a></li>
<li class="toctree-l4"><a class="reference internal" href="#strain-rate-smoothing">Strain rate smoothing</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#exponential-rift-stretching-profile">Exponential rift stretching profile</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#rift-left-right-plate-ids">Rift left/right plate IDs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rift-exponential-stretching-constant">Rift exponential stretching constant</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rift-strain-rate-resolution">Rift strain rate resolution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#rift-edge-length-threshold">Rift edge length threshold</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="pygplates_sample_code.html">Sample code</a></li>
<li class="toctree-l1"><a class="reference internal" href="pygplates_reference.html">Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">pygplates</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Primer</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/pygplates_primer.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="primer">
<span id="pygplates-primer"></span><h1>Primer<a class="headerlink" href="#primer" title="Link to this heading"></a></h1>
<p>This document covers the main areas of pyGPlates functionality, and some plate tectonic foundations.</p>
<nav class="contents local" id="contents">
<ul class="simple">
<li><p><a class="reference internal" href="#plate-reconstruction-hierarchy" id="id7">Plate reconstruction hierarchy</a></p></li>
<li><p><a class="reference internal" href="#working-with-finite-rotations" id="id8">Working with finite rotations</a></p>
<ul>
<li><p><a class="reference internal" href="#composing-finite-rotations" id="id9">Composing finite rotations</a></p></li>
<li><p><a class="reference internal" href="#plate-circuit-paths" id="id10">Plate circuit paths</a></p></li>
<li><p><a class="reference internal" href="#equivalent-total-rotation" id="id11">Equivalent total rotation</a></p></li>
<li><p><a class="reference internal" href="#relative-total-rotation" id="id12">Relative total rotation</a></p></li>
<li><p><a class="reference internal" href="#equivalent-stage-rotation" id="id13">Equivalent stage rotation</a></p></li>
<li><p><a class="reference internal" href="#relative-stage-rotation" id="id14">Relative stage rotation</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#topologies" id="id15">Topologies</a></p>
<ul>
<li><p><a class="reference internal" href="#topological-model" id="id16">Topological model</a></p>
<ul>
<li><p><a class="reference internal" href="#topological-snapshot" id="id17">Topological snapshot</a></p>
<ul>
<li><p><a class="reference internal" href="#plate-boundary-statistics" id="id18">Plate boundary statistics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#topologically-reconstruct-geometries" id="id19">Topologically reconstruct geometries</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-topological-reconstruction" id="id20">What is topological reconstruction?</a></p></li>
<li><p><a class="reference internal" href="#using-topological-reconstruction" id="id21">Using topological reconstruction</a></p></li>
<li><p><a class="reference internal" href="#reconstructed-geometry-time-span" id="id22">Reconstructed geometry time span</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#deformation" id="id23">Deformation</a></p>
<ul>
<li><p><a class="reference internal" href="#topological-network" id="id24">Topological network</a></p></li>
<li><p><a class="reference internal" href="#rigid-blocks" id="id25">Rigid blocks</a></p></li>
<li><p><a class="reference internal" href="#network-triangulation" id="id26">Network triangulation</a></p></li>
<li><p><a class="reference internal" href="#strain-rates-in-triangulation" id="id27">Strain rates in triangulation</a></p>
<ul>
<li><p><a class="reference internal" href="#strain-rate-clamping" id="id28">Strain rate clamping</a></p></li>
<li><p><a class="reference internal" href="#strain-rate-smoothing" id="id29">Strain rate smoothing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#exponential-rift-stretching-profile" id="id30">Exponential rift stretching profile</a></p>
<ul>
<li><p><a class="reference internal" href="#rift-left-right-plate-ids" id="id31">Rift left/right plate IDs</a></p></li>
<li><p><a class="reference internal" href="#rift-exponential-stretching-constant" id="id32">Rift exponential stretching constant</a></p></li>
<li><p><a class="reference internal" href="#rift-strain-rate-resolution" id="id33">Rift strain rate resolution</a></p></li>
<li><p><a class="reference internal" href="#rift-edge-length-threshold" id="id34">Rift edge length threshold</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="plate-reconstruction-hierarchy">
<span id="pygplates-primer-plate-reconstruction-hierarchy"></span><h2><a class="toc-backref" href="#id7" role="doc-backlink">Plate reconstruction hierarchy</a><a class="headerlink" href="#plate-reconstruction-hierarchy" title="Link to this heading"></a></h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a class="reference external" href="http://www.gplates.org/publications.html">Next-generation plate-tectonic reconstructions using GPlates</a>
contains a good introduction to plate reconstruction hierarchies.</p>
</div>
<p>A plate-reconstruction hierarchy consists of a tree of total reconstruction poles at an instant in geological time.</p>
<p>Plate motions are described in terms of relative rotations between pairs of plates.
Every plate in the model moves relative to some other plate where, within each
of these plate pairs, one plate is considered the <em>moving</em> plate relative to the
other <em>fixed</em> plate. That <em>fixed</em> plate, in turn, moves relative to another plate
thus forming a tree-like structure known as the <em>reconstruction tree</em>.
Each of these <em>relative</em> rotations is an <em>edge</em> in the tree.</p>
<p>The following diagram shows a subset of the hierarchy of relative rotations used in GPlates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>             <span class="mi">000</span>
              <span class="o">|</span>
              <span class="o">|</span>  <span class="n">finite</span> <span class="n">rotation</span> <span class="p">(</span><span class="mi">001</span> <span class="n">rel</span><span class="o">.</span> <span class="mi">000</span><span class="p">)</span>
              <span class="o">|</span>
             <span class="mi">001</span>
              <span class="o">|</span>
              <span class="o">|</span>  <span class="n">finite</span> <span class="n">rotation</span> <span class="p">(</span><span class="mi">701</span> <span class="n">rel</span><span class="o">.</span> <span class="mi">001</span><span class="p">)</span>
              <span class="o">|</span>
             <span class="mi">701</span><span class="p">(</span><span class="n">AFR</span><span class="p">)</span>
             <span class="o">/|</span>\
            <span class="o">/</span> <span class="o">|</span> \  <span class="n">finite</span> <span class="n">rotation</span> <span class="p">(</span><span class="mi">802</span> <span class="n">rel</span><span class="o">.</span> <span class="mi">701</span><span class="p">)</span>
           <span class="o">/</span>  <span class="o">|</span>  \
        <span class="mi">201</span>  <span class="mi">702</span>  <span class="mi">802</span><span class="p">(</span><span class="n">ANT</span><span class="p">)</span>
         <span class="o">/</span>   <span class="o">/</span> \    \
        <span class="o">/</span>   <span class="o">/</span>   \    \  <span class="n">finite</span> <span class="n">rotation</span> <span class="p">(</span><span class="mi">801</span> <span class="n">rel</span><span class="o">.</span> <span class="mi">802</span><span class="p">)</span>
       <span class="o">/</span>   <span class="o">/</span>     \    \
    <span class="mi">202</span>  <span class="mi">704</span>     <span class="mi">705</span>  <span class="mi">801</span><span class="p">(</span><span class="n">AUS</span><span class="p">)</span>
    <span class="o">/</span> \
   <span class="o">/</span>   \
  <span class="o">/</span>     \
<span class="mi">290</span>     <span class="mi">291</span>
</pre></div>
</div>
<p>…where <em>000</em> is the anchored plate (the top of the reconstruction tree).
The edge <em>802 rel. 701</em> contains the rotation of <em>802</em> (the moving plate in the pair) relative to
<em>701</em> (the fixed plate in the pair).</p>
<p>An <em>equivalent</em> rotation is the rotation of a plate relative to the <em>anchored</em> plate.
So the equivalent rotation of plate <em>802</em> is the composition of relative rotations along the
plate circuit <em>edge</em> path from anchored plate <em>000</em> to plate <em>802</em>.</p>
<p>A <em>relative</em> rotation is the rotation of one plate relative to <em>another</em> plate
(as opposed to the <em>anchored</em> plate). Note that, like <em>equivalent</em> rotations,
the plate circuit <em>edge</em> path can consist of one or more edges.
For example, the rotation of plate <em>801</em> relative to plate <em>291</em> follows an <em>edge</em>
path that goes via plates <em>202</em>, <em>201</em>, <em>701</em> and <em>802</em>. However it should be noted
that if the edge between <em>001</em> and <em>701</em> did not exist then, even though a path
would still exist between <em>291</em> and <em>801</em>, the <em>relative</em> rotation (and <em>equivalent</em>
rotations of <em>291</em> and <em>801</em> for that matter) would be an <a class="reference internal" href="generated/pygplates.FiniteRotation.html#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">identity</span> <span class="pre">rotation</span></code></a>. This is because the sub-tree
below <em>001</em> would not get built into the reconstruction tree and hence all plates
in the sub-tree would be missing. This can happen when the rotation sequence
for a moving/fixed plate pair (eg, <em>701</em>/<em>101</em>) does not span a large enough time
period. You can work around this situation by setting the anchor plate to the relative plate
(eg, <em>291</em> in the above example).</p>
<p>A <em>total</em> rotation is a rotation at a time in the past relative to <em>present day</em> (0Ma).
In other words <em>from</em> present day <em>to</em> a past time.</p>
<p>A <em>stage</em> rotation is a rotation at a time in the past relative to <em>another</em> time
in the past.</p>
</section>
<section id="working-with-finite-rotations">
<span id="pygplates-primer-working-with-finite-rotations"></span><h2><a class="toc-backref" href="#id8" role="doc-backlink">Working with finite rotations</a><a class="headerlink" href="#working-with-finite-rotations" title="Link to this heading"></a></h2>
<p>A finite rotation represents the motion of a plate (relative to another plate) on the surface of the
globe over a period of geological time.</p>
<p>In pyGPlates, finite rotations are represented by <a class="reference internal" href="generated/pygplates.FiniteRotation.html#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.FiniteRotation</span></code></a>.</p>
<p>In the following sections we will first cover some rotation maths and then derive the four
fundamental finite rotation categories:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#pygplates-primer-equivalent-total-rotation"><span class="std std-ref">Equivalent total rotation</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-relative-total-rotation"><span class="std std-ref">Relative total rotation</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-equivalent-stage-rotation"><span class="std std-ref">Equivalent stage rotation</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-relative-stage-rotation"><span class="std std-ref">Relative stage rotation</span></a></p></li>
</ul>
<p>In pyGPlates, these can be obtained from a <a class="reference internal" href="generated/pygplates.RotationModel.html#pygplates.RotationModel" title="pygplates.RotationModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.RotationModel</span></code></a>.</p>
<section id="composing-finite-rotations">
<span id="pygplates-primer-composing-finite-rotations"></span><h3><a class="toc-backref" href="#id9" role="doc-backlink">Composing finite rotations</a><a class="headerlink" href="#composing-finite-rotations" title="Link to this heading"></a></h3>
<p>In the following examples a composed rotation <span class="math notranslate nohighlight">\(R2 \times R1\)</span> means the rotation <span class="math notranslate nohighlight">\(R1\)</span>
is the first rotation to be applied followed by the rotation <span class="math notranslate nohighlight">\(R2\)</span> such that a geometry is
rotated in the following way:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{geometry_final} &amp;= R2 \times(R1 \times \text{geometry_initial}) \\
                      &amp;= R2 \times R1 \times \text{geometry_initial}\end{split}\]</div>
<p>…which is the equivalent of…</p>
<div class="math notranslate nohighlight">
\[\begin{split}\text{geometry_intermediate} &amp;= R1 \times \text{geometry_initial} \\
\text{geometry_final} &amp;= R2 \times \text{geometry_intermediate} \\
                      &amp;= R2 \times (R1 \times \text{geometry_initial}) \\
                      &amp;= R2 \times R1 \times \text{geometry_initial}\end{split}\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Rotations are <em>not</em> commutative (<span class="math notranslate nohighlight">\(R2 \times R1 \neq R1 \times R2\)</span>)</p>
</div>
<p>The composed rotation <span class="math notranslate nohighlight">\(R2 \times R1\)</span> can be written in pyGPlates as either:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">R2</span> <span class="o">*</span> <span class="n">R1</span>
</pre></div>
</div>
<p>…or…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">R1</span><span class="p">)</span>
</pre></div>
</div>
<p>For example, the above geometry rotation can be written as either:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">geometry_final</span> <span class="o">=</span> <span class="n">R2</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">*</span> <span class="n">geometry_initial</span>
</pre></div>
</div>
<p>…or…</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">geometry_final</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">R2</span><span class="p">,</span> <span class="n">R1</span><span class="p">)</span> <span class="o">*</span> <span class="n">geometry_initial</span>
</pre></div>
</div>
</section>
<section id="plate-circuit-paths">
<span id="pygplates-primer-plate-circuit-paths"></span><h3><a class="toc-backref" href="#id10" role="doc-backlink">Plate circuit paths</a><a class="headerlink" href="#plate-circuit-paths" title="Link to this heading"></a></h3>
<p>The rotation from present day (0Ma) to the <em>geological time</em> <span class="math notranslate nohighlight">\(t_{2}\)</span> (via time <span class="math notranslate nohighlight">\(t_{1}\)</span>) is given by:</p>
<div class="math notranslate nohighlight">
\[R(0 \rightarrow t_{2}) = R(t_{1} \rightarrow t_{2}) \times R(0 \rightarrow t_{1})\]</div>
<p>…or by post-multiplying both sides by <span class="math notranslate nohighlight">\(R(t_{1} \rightarrow 0)\)</span>, and then swapping sides, this becomes…</p>
<div class="math notranslate nohighlight">
\[\begin{split}R(0 \rightarrow t_{2}) \times R(t_{1} \rightarrow 0) &amp;= R(t_{1} \rightarrow t_{2}) \times R(0 \rightarrow t_{1}) \times R(t_{1} \rightarrow 0) \\
R(0 \rightarrow t_{2}) \times R(t_{1} \rightarrow 0) &amp;= R(t_{1} \rightarrow t_{2}) \\
R(t_{1} \rightarrow t_{2}) &amp;= R(0 \rightarrow t_{2}) \times R(t_{1} \rightarrow 0)\end{split}\]</div>
<p>The <em>plate circuit path</em> rotation from anchor plate <span class="math notranslate nohighlight">\(P_{A}\)</span> to moving plate <span class="math notranslate nohighlight">\(P_{M}\)</span> (via fixed plate <span class="math notranslate nohighlight">\(P_{F}\)</span>) is given by:</p>
<div class="math notranslate nohighlight">
\[R(P_{A} \rightarrow P_{M}) = R(P_{A} \rightarrow P_{F}) \times R(P_{F} \rightarrow P_{M})\]</div>
<p>…or by pre-multiplying both sides by <span class="math notranslate nohighlight">\(R(P_{F} \rightarrow P_{A})\)</span> this becomes…</p>
<div class="math notranslate nohighlight">
\[\begin{split}R(P_{F} \rightarrow P_{A}) \times R(P_{A} \rightarrow P_{M}) &amp;= R(P_{F} \rightarrow P_{A}) \times R(P_{A} \rightarrow P_{F}) \times R(P_{F} \rightarrow P_{M}) \\
R(P_{F} \rightarrow P_{A}) \times R(P_{A} \rightarrow P_{M}) &amp;= R(P_{F} \rightarrow P_{M}) \\
R(P_{F} \rightarrow P_{M}) &amp;= R(P_{F} \rightarrow P_{A}) \times R(P_{A} \rightarrow P_{M})\end{split}\]</div>
<p>Note that the rotations for relative times and for relative plates have the opposite order of each other !</p>
<p>In other words:</p>
<ul>
<li><p>For times <span class="math notranslate nohighlight">\(0 \rightarrow t_{1} \rightarrow t_{2}\)</span> you apply the <span class="math notranslate nohighlight">\(0 \rightarrow t_{1}\)</span> rotation first followed by the <span class="math notranslate nohighlight">\(t_{1} \rightarrow t_{2}\)</span> rotation:</p>
<div class="math notranslate nohighlight">
\[R(0 \rightarrow t_{2})  = R(t_{1} \rightarrow t_{2}) \times R(0 \rightarrow t_{1})\]</div>
</li>
<li><p>For plate circuit <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{F} \rightarrow P_{M}\)</span> you apply the <span class="math notranslate nohighlight">\(P_{F} \rightarrow P_{M}\)</span> rotation first followed by the <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{F}\)</span> rotation:</p>
<div class="math notranslate nohighlight">
\[R(P_{A} \rightarrow P_{M}) = R(P_{A} \rightarrow P_{F}) \times R(P_{F} \rightarrow P_{M})\]</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is not <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{F}\)</span> followed by <span class="math notranslate nohighlight">\(P_{F} \rightarrow P_{M}\)</span> as you might expect (looking at the time example).</p>
</div>
</li>
</ul>
<p>This is probably best explained by the difference between thinking in terms of the grand fixed
coordinate system and local coordinate system (see <a class="reference external" href="http://glprogramming.com/red/chapter03.html#name2">http://glprogramming.com/red/chapter03.html#name2</a>).
Essentially, in the plate circuit <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{F} \rightarrow P_{M}\)</span>, the <span class="math notranslate nohighlight">\(P_{F} \rightarrow P_{M}\)</span> rotation can be thought of as a rotation
within the local coordinate system of <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{F}\)</span>. In other words <span class="math notranslate nohighlight">\(P_{F} \rightarrow P_{M}\)</span> is not a rotation that
occurs relative to the global spin axis but a rotation relative to the local coordinate system
of plate <span class="math notranslate nohighlight">\(P_{F}\)</span> <em>after</em> it has been rotated relative to the anchor plate <span class="math notranslate nohighlight">\(P_{A}\)</span>.</p>
<p>For the times <span class="math notranslate nohighlight">\(0 \rightarrow t_{1} \rightarrow t_{2}\)</span> this local/relative coordinate system concept does not apply.</p>
<p>Note that a rotation must be relative to present day (0Ma) before it can be separated into a (plate circuit) chain of moving/fixed plate pairs.
Hence <span class="math notranslate nohighlight">\(R(t_{1} \rightarrow t_{2},P_{A} \rightarrow P_{C}) \neq R(t_{1} \rightarrow t_{2},P_{A} \rightarrow P_{B}) \times R(t_{1} \rightarrow t_{2},P_{B} \rightarrow P_{C})\)</span>
demonstrates this mistake.</p>
<p>The following shows the correct way to separate <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{C}\)</span> into the (plate circuit) chain of moving/fixed plate pairs <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{B}\)</span> and <span class="math notranslate nohighlight">\(P_{B} \rightarrow P_{C}\)</span>…</p>
<div class="math notranslate nohighlight">
\[\begin{split}R(t_{1} \rightarrow t_{2},P_{A} \rightarrow P_{C}) \\
&amp; = R(0 \rightarrow t_{2},P_{A} \rightarrow P_{C}) \times R(t_{1} \rightarrow 0,P_{A} \rightarrow P_{C}) \\
&amp; = R(0 \rightarrow t_{2},P_{A} \rightarrow P_{C}) \times R(0 \rightarrow t_{1},P_{A} \rightarrow P_{C})^{-1} \\
&amp;   \text{// Now that all times are relative to 0Ma we can split } P_{A} \rightarrow P_{C} \text{ into } P_{A} \rightarrow P_{B} \rightarrow P_{C} \text{ ...} \\
&amp; = R(0 \rightarrow t_{2},P_{A} \rightarrow P_{B}) \times R(0 \rightarrow t_{2},P_{B} \rightarrow P_{C}) \times [R(0 \rightarrow t_{1},P_{A} \rightarrow P_{B}) \times R(0 \rightarrow t_{1},P_{B} \rightarrow P_{C})]^{-1} \\
&amp; = R(0 \rightarrow t_{2},P_{A} \rightarrow P_{B}) \times R(0 \rightarrow t_{2},P_{B} \rightarrow P_{C}) \times R(0 \rightarrow t_{1},P_{B} \rightarrow P_{C})^{-1} \times R(0 \rightarrow t_{1},P_{A} \rightarrow P_{B})^{-1}\end{split}\]</div>
<p>…where <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{B} \rightarrow P_{C}\)</span> means <span class="math notranslate nohighlight">\(P_{B} \rightarrow P_{C}\)</span> is the rotation of <span class="math notranslate nohighlight">\(P_{C}\)</span> relative to <span class="math notranslate nohighlight">\(P_{B}\)</span> and <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{B}\)</span> is
the rotation of <span class="math notranslate nohighlight">\(P_{B}\)</span> relative to <span class="math notranslate nohighlight">\(P_{A}\)</span>. The need for rotation <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{C}\)</span> to be relative
to present day (0Ma) before it can be split into <span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{B}\)</span> and <span class="math notranslate nohighlight">\(P_{B} \rightarrow P_{C}\)</span> is because
<span class="math notranslate nohighlight">\(P_{A} \rightarrow P_{B}\)</span> and <span class="math notranslate nohighlight">\(P_{B} \rightarrow P_{C}\)</span> are defined (in the rotation file) as total reconstruction
poles which are always relative to present day.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<div class="line-block">
<div class="line">The inverse of rotation <span class="math notranslate nohighlight">\(R\)</span> is denoted <span class="math notranslate nohighlight">\(R^{-1}\)</span>.</div>
<div class="line">Such that <span class="math notranslate nohighlight">\(R \times R^{-1} = R^{-1} \times R = I\)</span> where <span class="math notranslate nohighlight">\(I\)</span> is the <a class="reference internal" href="generated/pygplates.FiniteRotation.html#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">identify</span> <span class="pre">rotation</span></code></a>.</div>
</div>
</div>
</section>
<section id="equivalent-total-rotation">
<span id="pygplates-primer-equivalent-total-rotation"></span><h3><a class="toc-backref" href="#id11" role="doc-backlink">Equivalent total rotation</a><a class="headerlink" href="#equivalent-total-rotation" title="Link to this heading"></a></h3>
<p>The equivalent total rotation of moving plate <span class="math notranslate nohighlight">\(P_{M}\)</span> relative to anchor plate <span class="math notranslate nohighlight">\(P_{A}\)</span>, and
from present day time <span class="math notranslate nohighlight">\(0\)</span> to time <span class="math notranslate nohighlight">\(t_{to}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M})\]</div>
<p>In pyGPlates, the equivalent total rotation can be obtained <a class="reference internal" href="generated/pygplates.RotationModel.html#pygplates.RotationModel.get_rotation" title="pygplates.RotationModel.get_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.RotationModel.get_rotation()</span></code></a> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">equivalent_total_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="n">to_time</span><span class="p">,</span> <span class="n">moving_plate</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="relative-total-rotation">
<span id="pygplates-primer-relative-total-rotation"></span><h3><a class="toc-backref" href="#id12" role="doc-backlink">Relative total rotation</a><a class="headerlink" href="#relative-total-rotation" title="Link to this heading"></a></h3>
<p>The relative total rotation of moving plate <span class="math notranslate nohighlight">\(P_{M}\)</span> relative to fixed plate <span class="math notranslate nohighlight">\(P_{F}\)</span>, and
from present day time <span class="math notranslate nohighlight">\(0\)</span> to time <span class="math notranslate nohighlight">\(t_{to}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}R(0 \rightarrow t_{to},P_{F} \rightarrow P_{M}) \\
&amp;  = R(0 \rightarrow t_{to},P_{F} \rightarrow P_{A}) \times R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M}) \\
&amp;  = R(0 \rightarrow t_{to},P_{A} \rightarrow P_{F})^{-1} \times R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M})\end{split}\]</div>
<p>…where <span class="math notranslate nohighlight">\(P_{A}\)</span> is the anchor plate.</p>
<p>In pyGPlates, the relative total rotation can be obtained from <a class="reference internal" href="generated/pygplates.RotationModel.html#pygplates.RotationModel.get_rotation" title="pygplates.RotationModel.get_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.RotationModel.get_rotation()</span></code></a> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">relative_total_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="n">to_time</span><span class="p">,</span> <span class="n">moving_plate</span><span class="p">,</span> <span class="n">fixed_plate_id</span><span class="o">=</span><span class="n">fixed_plate</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="equivalent-stage-rotation">
<span id="pygplates-primer-equivalent-stage-rotation"></span><h3><a class="toc-backref" href="#id13" role="doc-backlink">Equivalent stage rotation</a><a class="headerlink" href="#equivalent-stage-rotation" title="Link to this heading"></a></h3>
<p>The equivalent stage rotation of moving plate <span class="math notranslate nohighlight">\(P_{M}\)</span> relative to anchor plate <span class="math notranslate nohighlight">\(P_{A}\)</span>, and
from time <span class="math notranslate nohighlight">\(t_{from}\)</span> to time <span class="math notranslate nohighlight">\(t_{to}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}R(t_{from} \rightarrow t_{to},P_{A} \rightarrow P_{M}) \\
&amp;  = R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M}) \times R(t_{from} \rightarrow 0,P_{A} \rightarrow P_{M}) \\
&amp;  = R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M}) \times R(0 \rightarrow t_{from},P_{A} \rightarrow P_{M})^{-1}\end{split}\]</div>
<p>In pyGPlates, the equivalent stage rotation can be obtained <a class="reference internal" href="generated/pygplates.RotationModel.html#pygplates.RotationModel.get_rotation" title="pygplates.RotationModel.get_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.RotationModel.get_rotation()</span></code></a> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">equivalent_stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="n">to_time</span><span class="p">,</span> <span class="n">moving_plate</span><span class="p">,</span> <span class="n">from_time</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="relative-stage-rotation">
<span id="pygplates-primer-relative-stage-rotation"></span><h3><a class="toc-backref" href="#id14" role="doc-backlink">Relative stage rotation</a><a class="headerlink" href="#relative-stage-rotation" title="Link to this heading"></a></h3>
<p>The relative stage rotation of moving plate <span class="math notranslate nohighlight">\(P_{M}\)</span> relative to fixed plate <span class="math notranslate nohighlight">\(P_{F}\)</span>, and
from time <span class="math notranslate nohighlight">\(t_{from}\)</span> to time <span class="math notranslate nohighlight">\(t_{to}\)</span> is:</p>
<div class="math notranslate nohighlight">
\[\begin{split}R(t_{from} \rightarrow t_{to},P_{F} \rightarrow P_{M}) \\
&amp;  = R(0 \rightarrow t_{to},P_{F} \rightarrow P_{M}) \times R(t_{from} \rightarrow 0,P_{F} \rightarrow P_{M}) \\
&amp;  = R(0 \rightarrow t_{to},P_{F} \rightarrow P_{M}) \times R(0 \rightarrow t_{from},P_{F} \rightarrow P_{M})^{-1} \\
&amp;  = R(0 \rightarrow t_{to},P_{F} \rightarrow P_{A}) \times R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M}) \times [R(0 \rightarrow t_{from},P_{F} \rightarrow P_{A}) \times R(0 \rightarrow t_{from},P_{A} \rightarrow P_{M})]^{-1} \\
&amp;  = R(0 \rightarrow t_{to},P_{A} \rightarrow P_{F})^{-1} \times R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M}) \times [R(0 \rightarrow t_{from},P_{A} \rightarrow P_{F})^{-1} \times R(0 \rightarrow t_{from},P_{A} \rightarrow P_{M})]^{-1} \\
&amp;  = R(0 \rightarrow t_{to},P_{A} \rightarrow P_{F})^{-1} \times R(0 \rightarrow t_{to},P_{A} \rightarrow P_{M}) \times R(0 \rightarrow t_{from},P_{A} \rightarrow P_{M})^{-1} \times R(0 \rightarrow t_{from},P_{A} \rightarrow P_{F})\end{split}\]</div>
<p>…where <span class="math notranslate nohighlight">\(P_{A}\)</span> is the anchor plate.</p>
<p>In pyGPlates, the relative stage rotation can be obtained <a class="reference internal" href="generated/pygplates.RotationModel.html#pygplates.RotationModel.get_rotation" title="pygplates.RotationModel.get_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.RotationModel.get_rotation()</span></code></a> as:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">relative_stage_rotation</span> <span class="o">=</span> <span class="n">rotation_model</span><span class="o">.</span><span class="n">get_rotation</span><span class="p">(</span><span class="n">to_time</span><span class="p">,</span> <span class="n">moving_plate</span><span class="p">,</span> <span class="n">from_time</span><span class="p">,</span> <span class="n">fixed_plate</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
<section id="topologies">
<span id="pygplates-primer-topologies"></span><h2><a class="toc-backref" href="#id15" role="doc-backlink">Topologies</a><a class="headerlink" href="#topologies" title="Link to this heading"></a></h2>
<p>This section covers topologies in pyGPlates.</p>
<nav class="contents local" id="id1">
<ul class="simple">
<li><p><a class="reference internal" href="#topological-model" id="id35">Topological model</a></p>
<ul>
<li><p><a class="reference internal" href="#topological-snapshot" id="id36">Topological snapshot</a></p>
<ul>
<li><p><a class="reference internal" href="#plate-boundary-statistics" id="id37">Plate boundary statistics</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#topologically-reconstruct-geometries" id="id38">Topologically reconstruct geometries</a></p>
<ul>
<li><p><a class="reference internal" href="#what-is-topological-reconstruction" id="id39">What is topological reconstruction?</a></p>
<ul>
<li><p><a class="reference internal" href="#reconstruction-plate-id" id="id40">Reconstruction plate ID</a></p></li>
<li><p><a class="reference internal" href="#deactivating-points" id="id41">Deactivating points</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#using-topological-reconstruction" id="id42">Using topological reconstruction</a></p>
<ul>
<li><p><a class="reference internal" href="#time-spans" id="id43">Time spans</a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-using-topological-reconstruction-reconstruction-plate-id" id="id44">Reconstruction plate ID</a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-using-topological-reconstruction-deactivating-points" id="id45">Deactivating points</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reconstructed-geometry-time-span" id="id46">Reconstructed geometry time span</a></p>
<ul>
<li><p><a class="reference internal" href="#geometry-points" id="id47">Geometry points</a></p></li>
<li><p><a class="reference internal" href="#topology-locations" id="id48">Topology locations</a></p></li>
<li><p><a class="reference internal" href="#velocities" id="id49">Velocities</a></p></li>
<li><p><a class="reference internal" href="#strain-rates" id="id50">Strain rates</a></p></li>
<li><p><a class="reference internal" href="#strains" id="id51">Strains</a></p></li>
<li><p><a class="reference internal" href="#scalar-values" id="id52">Scalar values</a></p></li>
<li><p><a class="reference internal" href="#crustal-thickness-factors" id="id53">Crustal thickness factors</a></p></li>
<li><p><a class="reference internal" href="#tectonic-subsidence" id="id54">Tectonic subsidence</a></p></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
<section id="topological-model">
<span id="pygplates-primer-topological-model"></span><h3><a class="toc-backref" href="#id35" role="doc-backlink">Topological model</a><a class="headerlink" href="#topological-model" title="Link to this heading"></a></h3>
<p>A topological model is represented by a <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a>.
It can be created from topological features (in files, <a class="reference internal" href="generated/pygplates.Feature.html#pygplates.Feature" title="pygplates.Feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">features</span></code></a> or
<a class="reference internal" href="generated/pygplates.FeatureCollection.html#pygplates.FeatureCollection" title="pygplates.FeatureCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">feature</span> <span class="pre">collections</span></code></a>) and a rotation model (created from rotation files,
<a class="reference internal" href="generated/pygplates.Feature.html#pygplates.Feature" title="pygplates.Feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">features</span></code></a> or <a class="reference internal" href="generated/pygplates.FeatureCollection.html#pygplates.FeatureCollection" title="pygplates.FeatureCollection"><code class="xref py py-class docutils literal notranslate"><span class="pre">feature</span> <span class="pre">collections</span></code></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rotation_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">RotationModel</span><span class="p">(</span><span class="s1">&#39;rotations.rot&#39;</span><span class="p">)</span>
<span class="n">topological_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalModel</span><span class="p">(</span><span class="s1">&#39;topologies.gpml&#39;</span><span class="p">,</span> <span class="n">rotation_model</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Alternatively you can just pass the rotation filenames (or features) directly into the topological model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topological_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalModel</span><span class="p">(</span><span class="s1">&#39;topologies.gpml&#39;</span><span class="p">,</span> <span class="s1">&#39;rotations.rot&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>You can also control <em>how</em> topologies are resolved using <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters" title="pygplates.ResolveTopologyParameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters</span></code></a> -
currently these parameters only affect deforming networks.
This is done by specifying the <code class="docutils literal notranslate"><span class="pre">default_resolve_topology_parameters</span></code> - see
<a class="reference internal" href="#pygplates-primer-strain-rate-clamping"><span class="std std-ref">Strain rate clamping</span></a>, <a class="reference internal" href="#pygplates-primer-strain-rate-smoothing"><span class="std std-ref">Strain rate smoothing</span></a> and
<a class="reference internal" href="#pygplates-primer-exponential-rift-stretching-profile"><span class="std std-ref">Exponential rift stretching profile</span></a> for more details.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can also override the default parameters for each topological entry (eg, each file, feature collection or feature)
by specifying a 2-tuple (topological entry, <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters" title="pygplates.ResolveTopologyParameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters</span></code></a>) instead of just the topological entry.</p>
</div>
<p>A topological model can:</p>
<ul class="simple">
<li><p>Create a <a class="reference internal" href="#pygplates-primer-topological-snapshot"><span class="std std-ref">Topological snapshot</span></a> at a reconstruction time.</p></li>
<li><p><a class="reference internal" href="#pygplates-primer-topologically-reconstruct-geometries"><span class="std std-ref">Topologically reconstruct geometries</span></a> over a time range.</p></li>
</ul>
<section id="topological-snapshot">
<span id="pygplates-primer-topological-snapshot"></span><h4><a class="toc-backref" href="#id36" role="doc-backlink">Topological snapshot</a><a class="headerlink" href="#topological-snapshot" title="Link to this heading"></a></h4>
<p>A topological snapshot is represented by a <a class="reference internal" href="generated/pygplates.TopologicalSnapshot.html#pygplates.TopologicalSnapshot" title="pygplates.TopologicalSnapshot"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalSnapshot</span></code></a>.
It can be created by resolving a <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a> to a specific reconstruction time.
For example, to create a topological snapshot for each reconstruction time from 0 to 1000Ma in 1Myr increments:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">reconstruction_time</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
   <span class="n">topological_snapshot</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">topological_snapshot</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, a topological snapshot can be created directly from topological features and a rotation model
(similar to <a class="reference internal" href="#pygplates-primer-topological-model"><span class="std std-ref">how a topological model is created</span></a>) and a reconstruction time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">reconstruction_time</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
   <span class="n">topological_snapshot</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalSnapshot</span><span class="p">(</span><span class="s1">&#39;topologies.gpml&#39;</span><span class="p">,</span> <span class="n">rotation_model</span><span class="p">,</span> <span class="n">reconstruction_time</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is more efficient to generate snapshots from a <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a> (rather than explicity using
<code class="docutils literal notranslate"><span class="pre">pygplates.TopologicalSnapshot(...)</span></code>). This is because a topological model only needs to read/parse the input topological and
rotation features once, rather than at each time step. And also, the topological snapshots are cached internally within the
topological model, so requesting the same snapshot again (at the same reconstruction time) will not require the topologies to
be resolved again (at that reconstruction time).</p>
</div>
<p>A topological snapshot can:</p>
<ul class="simple">
<li><p>Generate <a class="reference internal" href="#pygplates-primer-plate-boundary-statistics"><span class="std std-ref">Plate boundary statistics</span></a> (like convergence/divergence) along plate boundaries.</p></li>
</ul>
<section id="plate-boundary-statistics">
<span id="pygplates-primer-plate-boundary-statistics"></span><h5><a class="toc-backref" href="#id37" role="doc-backlink">Plate boundary statistics</a><a class="headerlink" href="#plate-boundary-statistics" title="Link to this heading"></a></h5>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following sample codes use plate boundary statistics:</p>
<ul class="simple">
<li><p><a class="reference internal" href="sample-code/pygplates_find_divergence_at_subduction_zones_and_convergence_at_ridges.html#pygplates-find-divergence-at-subduction-zones-and-convergence-at-ridges"><span class="std std-ref">Find divergence at subduction zones and convergence at ridges</span></a></p></li>
</ul>
</div>
<p>Statistics at uniformly spaced points along plate boundaries can be generated from a topological snapshot using
<a class="reference internal" href="generated/pygplates.TopologicalSnapshot.html#pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics" title="pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics()</span></code></a>.
For example, to generate statistics at points spaced 1 degree apart (along all plate boundaries):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">uniform_point_spacing_radians</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="n">plate_boundary_stats</span> <span class="o">=</span> <span class="n">topological_snapshot</span><span class="o">.</span><span class="n">calculate_plate_boundary_statistics</span><span class="p">(</span><span class="n">uniform_point_spacing_radians</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also restrict which plate boundaries to generate points along.
For example, to generate points only along subduction zones and mid-ocean ridges:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">plate_boundary_stats</span> <span class="o">=</span> <span class="n">topological_snapshot</span><span class="o">.</span><span class="n">calculate_plate_boundary_statistics</span><span class="p">(</span>
      <span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
      <span class="n">boundary_section_filter</span> <span class="o">=</span> <span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_subduction_zone</span><span class="p">,</span>
                                 <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_mid_ocean_ridge</span><span class="p">])</span>
</pre></div>
</div>
<p>…or even define your own criteria as a filter function accepting a single argument of type <a class="reference internal" href="generated/pygplates.ResolvedTopologicalSection.html#pygplates.ResolvedTopologicalSection" title="pygplates.ResolvedTopologicalSection"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalSection</span></code></a>
and returning <code class="docutils literal notranslate"><span class="pre">True</span></code> if uniform points should be generated along that boundary section. For example, the equivalent of the above
example (generating points only along subduction zones and mid-ocean ridges) would be:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">boundary_section_filter_function</span><span class="p">(</span><span class="n">resolved_topological_section</span><span class="p">):</span>
   <span class="n">feature_type</span> <span class="o">=</span> <span class="n">resolved_topological_section</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_feature_type</span><span class="p">()</span>
   <span class="k">return</span> <span class="p">(</span><span class="n">feature_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_subduction_zone</span> <span class="ow">or</span>
           <span class="n">feature_type</span> <span class="o">==</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FeatureType</span><span class="o">.</span><span class="n">gpml_mid_ocean_ridge</span><span class="p">)</span>

<span class="n">plate_boundary_stats</span> <span class="o">=</span> <span class="n">topological_snapshot</span><span class="o">.</span><span class="n">calculate_plate_boundary_statistics</span><span class="p">(</span>
      <span class="n">uniform_point_spacing_radians</span><span class="p">,</span>
      <span class="n">boundary_section_filter</span> <span class="o">=</span> <span class="n">boundary_section_filter_function</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>You can also group uniform points with the <a class="reference internal" href="generated/pygplates.ResolvedTopologicalSharedSubSegment.html#pygplates.ResolvedTopologicalSharedSubSegment" title="pygplates.ResolvedTopologicalSharedSubSegment"><code class="xref py py-class docutils literal notranslate"><span class="pre">shared</span> <span class="pre">sub-segment</span></code></a>
they came from by setting <a class="reference internal" href="generated/pygplates.TopologicalSnapshot.html#pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics" title="pygplates.TopologicalSnapshot.calculate_plate_boundary_statistics"><code class="xref py py-meth docutils literal notranslate"><span class="pre">return_shared_sub_segment_dict</span></code></a> to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</div>
<p>Each point gets its own statistic represented by a <a class="reference internal" href="generated/pygplates.PlateBoundaryStatistic.html#pygplates.PlateBoundaryStatistic" title="pygplates.PlateBoundaryStatistic"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.PlateBoundaryStatistic</span></code></a>.
For example, to query the uniformly spaced point locations and their convergence velocity magnitudes and obliquities:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">plate_boundary_stats</span><span class="p">:</span>
   <span class="n">boundary_point</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">boundary_point</span>
   <span class="k">if</span> <span class="n">convergence_velocity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># make sure the left and right plates exist</span>
      <span class="n">convergence_velocity_magnitude</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_magnitude</span>
      <span class="n">convergence_velocity_obliquity</span> <span class="o">=</span> <span class="n">stat</span><span class="o">.</span><span class="n">convergence_velocity_obliquity</span>
</pre></div>
</div>
<p>There are many other <a class="reference internal" href="generated/pygplates.PlateBoundaryStatistic.html#pygplates.PlateBoundaryStatistic" title="pygplates.PlateBoundaryStatistic"><code class="xref py py-class docutils literal notranslate"><span class="pre">statistics</span></code></a> such as plate <em>boundary</em> velocity, plate boundary <em>normal</em> direction,
left and right plate velocities, left and right plate identifiers (ie, which plate, or deforming network, is left and right of the point)
and distance to the ends of the boundary section (containing the point).</p>
</section>
</section>
<section id="topologically-reconstruct-geometries">
<span id="pygplates-primer-topologically-reconstruct-geometries"></span><h4><a class="toc-backref" href="#id38" role="doc-backlink">Topologically reconstruct geometries</a><a class="headerlink" href="#topologically-reconstruct-geometries" title="Link to this heading"></a></h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The following sample codes use topological reconstruction:</p>
<ul class="simple">
<li><p><a class="reference internal" href="sample-code/pygplates_reconstruct_strain_and_strain_rate.html#pygplates-reconstruct-strain-and-strain-rate"><span class="std std-ref">Reconstruct strain and strain rate</span></a></p></li>
<li><p><a class="reference internal" href="sample-code/pygplates_reconstruct_crustal_thickness_and_tectonic_subsidence.html#pygplates-reconstruct-crustal-thickness-and-tectonic-subsidence"><span class="std std-ref">Reconstruct crustal thickness and tectonic subsidence</span></a></p></li>
</ul>
</div>
<p>Usually features are reconstructed using <a class="reference internal" href="generated/pygplates.ReconstructModel.html#pygplates.ReconstructModel" title="pygplates.ReconstructModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructModel</span></code></a>, which relies only on the properties of the features
(such as their reconstruction plate IDs) to reconstruct them to past geological times.</p>
<p>An alternative approach is to use topologies (topological closed plate polygons and networks) to reconstruct an initial geometry.
In this case it is the topological plates and networks that determine how the geometry moves over time.
In other words, the geometry rigidly rotates when it is in rigid plates and deforms when it is in deforming networks.</p>
<nav class="contents local" id="id2">
<ul class="simple">
<li><p><a class="reference internal" href="#what-is-topological-reconstruction" id="id55">What is topological reconstruction?</a></p>
<ul>
<li><p><a class="reference internal" href="#reconstruction-plate-id" id="id56">Reconstruction plate ID</a></p></li>
<li><p><a class="reference internal" href="#deactivating-points" id="id57">Deactivating points</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#using-topological-reconstruction" id="id58">Using topological reconstruction</a></p>
<ul>
<li><p><a class="reference internal" href="#time-spans" id="id59">Time spans</a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-using-topological-reconstruction-reconstruction-plate-id" id="id60">Reconstruction plate ID</a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-using-topological-reconstruction-deactivating-points" id="id61">Deactivating points</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#reconstructed-geometry-time-span" id="id62">Reconstructed geometry time span</a></p>
<ul>
<li><p><a class="reference internal" href="#geometry-points" id="id63">Geometry points</a></p></li>
<li><p><a class="reference internal" href="#topology-locations" id="id64">Topology locations</a></p></li>
<li><p><a class="reference internal" href="#velocities" id="id65">Velocities</a></p></li>
<li><p><a class="reference internal" href="#strain-rates" id="id66">Strain rates</a></p></li>
<li><p><a class="reference internal" href="#strains" id="id67">Strains</a></p></li>
<li><p><a class="reference internal" href="#scalar-values" id="id68">Scalar values</a></p></li>
<li><p><a class="reference internal" href="#crustal-thickness-factors" id="id69">Crustal thickness factors</a></p></li>
<li><p><a class="reference internal" href="#tectonic-subsidence" id="id70">Tectonic subsidence</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="what-is-topological-reconstruction">
<span id="pygplates-primer-what-is-topological-reconstruction"></span><h5><a class="toc-backref" href="#id55" role="doc-backlink">What is topological reconstruction?</a><a class="headerlink" href="#what-is-topological-reconstruction" title="Link to this heading"></a></h5>
<p>Topological reconstruction is an incremental process whereby each point in an initial geometry is reconstructed over a time period by dividing
that time period into a series of smaller time intervals. Within each time interval, the geometry at the start of the interval is reconstructed
to the end of the interval using the resolved topologies (at the start of the interval). This incremental reconstruction is performed iteratively
over the full time period to obtain a history of reconstruction snapshots (of the geometry), with each snapshot occupying a time slot.</p>
<p>For each new time interval, the resolved topologies can change, such as plates splitting/merging and deforming networks appearing/disappearing.
So at the start of each time interval, each point of the geometry is tested to see which topological plate or network it lies within
(with higher priority given to networks since they typically overlay the rigid plates). Then each point is reconstructed over the time interval
using the topological plate (see <a class="reference internal" href="generated/pygplates.ResolvedTopologicalBoundary.html#pygplates.ResolvedTopologicalBoundary.reconstruct_point" title="pygplates.ResolvedTopologicalBoundary.reconstruct_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalBoundary.reconstruct_point()</span></code></a>) or topological network
(see <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork.reconstruct_point" title="pygplates.ResolvedTopologicalNetwork.reconstruct_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalNetwork.reconstruct_point()</span></code></a>) that the point lies within.</p>
<section id="reconstruction-plate-id">
<span id="pygplates-primer-what-is-topological-reconstruction-reconstruction-plate-id"></span><h6><a class="toc-backref" href="#id56" role="doc-backlink">Reconstruction plate ID</a><a class="headerlink" href="#reconstruction-plate-id" title="Link to this heading"></a></h6>
<p>Since topological reconstruction is peformed using topologies, no feature properties are needed (in contrast with non-topological reconstruction
using <a class="reference internal" href="generated/pygplates.ReconstructModel.html#pygplates.ReconstructModel" title="pygplates.ReconstructModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructModel</span></code></a>). However, if a geometry point does not intersect any resolved topologies during a time interval then an
optional reconstruction plate ID is used to <em>rigidly</em> reconstruct it over that time interval. And if a reconstruction plate ID was not provided then
the point does not move over that time interval.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some geometry points can fail to intersect topologies if the topologies are regional (instead of global), or if there are cracks
between adjacent topologies (due to the way they were built).</p>
</div>
</section>
<section id="deactivating-points">
<span id="pygplates-primer-what-is-topological-reconstruction-deactivating-points"></span><h6><a class="toc-backref" href="#id57" role="doc-backlink">Deactivating points</a><a class="headerlink" href="#deactivating-points" title="Link to this heading"></a></h6>
<p>The history of reconstruction snapshots covers a time range from an oldest time to a youngest time. And the initial geometry is provided at an
initial time (that can be inside or outside that time range). Hence an initial geometry can be topologically reconstructed forward in time, or
backward in time, or both, depending on where the initial time is in relation to the oldest and youngest times.</p>
<p>Initially all geometry points are active at the <em>initial time</em>, but can get progressively deactivated as they are topologically reconstructed
<em>away</em> from the initial time. When a point is deactivated it becomes inactive and is no longer topologically reconstructed for subsequent
time slots (<em>further</em> from the initial time). When reconstructed <em>forward</em> in time, points on oceanic crust get deactivated as they are subducted.
And when reconstructed <em>backward</em> in time, they get deactivated as they reach their time of appearance (at a mid-ocean ridge).</p>
</section>
</section>
<section id="using-topological-reconstruction">
<span id="pygplates-primer-using-topological-reconstruction"></span><h5><a class="toc-backref" href="#id58" role="doc-backlink">Using topological reconstruction</a><a class="headerlink" href="#using-topological-reconstruction" title="Link to this heading"></a></h5>
<p>Topological reconstruction requires a <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a> and a geometry. Currently the geometry can only be one or more points.
Then <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a> can be used to generate a reconstructed history of snapshots of the geometry points,
and associated quantities (like velocity), that are stored in the returned <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan" title="pygplates.ReconstructedGeometryTimeSpan"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan</span></code></a>.
For example, to topologically reconstruct points from their initial positions at 100 Ma to present day, in increments of 1 Myr:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Convert from latitudes and longitudes to a list of pygplates.PointOnSphere.</span>
<span class="n">lats</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>  <span class="c1"># point latitudes</span>
<span class="n">lons</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>  <span class="c1"># point longitudes</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">lat</span><span class="p">,</span> <span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span> <span class="n">lons</span><span class="p">)]</span>

<span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>The returned <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan" title="pygplates.ReconstructedGeometryTimeSpan"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan</span></code></a> contains 101 reconstructed snapshots of the initial geometry in its history.
You can use it to query the reconstructed geometry at any reconstruction time. For example, to query the reconstructed points at 50 Ma:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_points</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_geometry_points</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>

<span class="k">if</span> <span class="n">reconstructed_points</span><span class="p">:</span>
   <span class="c1"># Convert from a list of pygplates.PointOnSphere to a list of (latitude, longitude) tuples.</span>
   <span class="n">reconstructed_lat_lons</span> <span class="o">=</span> <span class="p">[</span><span class="n">point</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span> <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">reconstructed_points</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span"><span class="std std-ref">Reconstructed geometry time span</span></a> for more details on querying reconstruction snapshots.</p>
</div>
<section id="time-spans">
<span id="pygplates-primer-using-topological-reconstruction-time-spans"></span><h6><a class="toc-backref" href="#id59" role="doc-backlink">Time spans</a><a class="headerlink" href="#time-spans" title="Link to this heading"></a></h6>
<p>The time span of snapshots is determined by the oldest and youngest times.</p>
<p>In the above example, points were reconstructed <em>forward</em> in time (from 100 Ma to present day).
So the oldest time was 100 Ma and the youngest was 0 Ma.</p>
<p>You can also reconstruct <em>backward</em> in time. For example, to reconstruct from present day to 100 Ma, in increments of 1 Myr:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">oldest_time</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>…where we needed to explicitly specify <code class="docutils literal notranslate"><span class="pre">oldest_time</span></code> because otherwise it defaults to <code class="docutils literal notranslate"><span class="pre">initial_time</span></code> (which in this example is present day).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Even though the reconstruction is <em>backward</em> in time, the oldest and youngest times are still 100 Ma and 0 Ma, respectively.</p>
</div>
<p>In the above cases, the youngest time defaults to present day. However you can explicitly set it using the <code class="docutils literal notranslate"><span class="pre">youngest_time</span></code> argument.
For example, if you only want a history of snapshots from 100 Ma to 50 Ma (instead of 100 Ma to present day):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
      <span class="n">oldest_time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
      <span class="n">youngest_time</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
</pre></div>
</div>
<p>It’s also possible to reconstruct both <em>forward</em> and <em>backward</em> in time. This happens when the initial time is <em>between</em> the oldest and youngest times.
For example, if the initial points are at 50 Ma but you want a time range of snapshots from 100 Ma to present day:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>
      <span class="n">oldest_time</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>In this case, the initial points are reconstructed both <em>forward</em> in time from 50 Ma to present day <strong>and</strong> <em>backward</em> in time from 50 Ma to 100 Ma
(in order to generate all snapshots from 100 Ma to present day).</p>
<p>You can also choose the time interval between reconstruction snapshots using the <code class="docutils literal notranslate"><span class="pre">time_increment</span></code> argument (which defaults to 1 Myr).
The time increment, along with the oldest and youngest times, determine the time slots.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">oldest_time</span> <span class="pre">-</span> <span class="pre">youngest_time</span></code> must be an integer multiple of <code class="docutils literal notranslate"><span class="pre">time_increment</span></code>.</p>
</div>
<p>If you choose a large time increment then the snapshots will be spaced farther apart and the resulting reconstruction accuracy will suffer.
Another source of inaccuracy is due to the initial time of the initial geometry being internally snapped to the nearest time slot.
For these reasons the time increment defaults to 1 Myr (which is typically the smallest time resolution used in topological models).</p>
</section>
<section id="pygplates-primer-using-topological-reconstruction-reconstruction-plate-id">
<span id="id3"></span><h6><a class="toc-backref" href="#id60" role="doc-backlink">Reconstruction plate ID</a><a class="headerlink" href="#pygplates-primer-using-topological-reconstruction-reconstruction-plate-id" title="Link to this heading"></a></h6>
<p>In the above cases, the geometry is already in the correct position at the initial time. In other words, the geometry is a snapshot at the initial time.
For example, it could be uniform points spread across the entire globe at the initial time (and we want to see where they end up at other times).
So we did <strong>not</strong> specify the <code class="docutils literal notranslate"><span class="pre">reconstruction_plate_id</span></code> argument.</p>
<p>However if the geometry is a <em>present day</em> geometry localised to a specific plate (and the initial time is in the past) then specifying a
reconstruction plate ID will reconstruct it to the initial time (to become the snapshot at the initial time, before topologically reconstruction into
the other snapshots proceeds). For example, if the geometry represents its present day position on plate 701 (and we’re reconstructing <em>forward</em> in time
from 100 Ma to present day) then:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points_at_present_day</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
      <span class="n">reconstruction_plate_id</span><span class="o">=</span><span class="mi">701</span><span class="p">)</span>
</pre></div>
</div>
<p>…will first rigidly reconstruct <code class="docutils literal notranslate"><span class="pre">points_at_present_day</span></code> from present day to 100 Ma using plate <code class="docutils literal notranslate"><span class="pre">701</span></code>, and then topologically reconstruct them
from 100 Ma to present day (generating snapshots at 1 Myr intervals).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><code class="docutils literal notranslate"><span class="pre">reconstruction_plate_id</span></code> also has other purposes. For example, when
<a class="reference internal" href="#pygplates-primer-what-is-topological-reconstruction-reconstruction-plate-id"><span class="std std-ref">generating the history of snapshots</span></a> and when
<a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">querying geometry points</span></a>.</p>
</div>
</section>
<section id="pygplates-primer-using-topological-reconstruction-deactivating-points">
<span id="id4"></span><h6><a class="toc-backref" href="#id61" role="doc-backlink">Deactivating points</a><a class="headerlink" href="#pygplates-primer-using-topological-reconstruction-deactivating-points" title="Link to this heading"></a></h6>
<p>By default, geometry points can get progressively deactivated when they are topologically reconstructed away from the initial time.
This is useful for points on <em>oceanic</em> crust because that crust can get subducted, and it is typically younger than continental crust.
Therefore, oceanic points will get deactivated as they are subducted going <em>forward</em> in time and deactivated as they reach their time of appearance
(at mid-ocean ridges) going <em>backward</em> in time. This is the default behaviour and works for both oceanic and continental crust.</p>
<p>To disable this ability you can explicitly set the <code class="docutils literal notranslate"><span class="pre">deactivate_points</span></code> argument to <code class="docutils literal notranslate"><span class="pre">None</span></code>. Then the points will always remain active.
This can be used (but is not necessary) when the points are all within the interior of <em>continents</em> (where crust exists at present day and has existed
for a long time). For example, to reconstruct <em>continental</em> points forward in time from 100 Ma to present day (without attempting to deactivate any):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
      <span class="n">deactivate_points</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
</pre></div>
</div>
<p>You can also change <em>how</em> points are deactivated, by either:</p>
<ul class="simple">
<li><p>changing the parameters of the <em>default</em> deactivation algorithm, or</p></li>
<li><p>implementing your own deactivation algorithm.</p></li>
</ul>
<p>The <em>default</em> deactivation algorithm is implemented in <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.DefaultDeactivatePoints" title="pygplates.ReconstructedGeometryTimeSpan.DefaultDeactivatePoints"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.DefaultDeactivatePoints</span></code></a>.</p>
<p>To use the <em>default</em> parameters of the <em>default</em> deactivation algorithm you don’t need to specify the <code class="docutils literal notranslate"><span class="pre">deactivate_points</span></code> argument.
For example, you can just call:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
</pre></div>
</div>
<p>…since that is equivalent to calling:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
      <span class="n">deactivate_points</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructedGeometryTimeSpan</span><span class="o">.</span><span class="n">DefaultDeactivatePoints</span><span class="p">())</span>
</pre></div>
</div>
<p>However, you can change the parameters of the <em>default</em> deactivation algorithm.
For example, when reconstructing <em>oceanic</em> points (forward in time from 100 Ma to present day):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">points</span><span class="p">,</span>
      <span class="n">initial_time</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>
      <span class="n">deactivate_points</span><span class="o">=</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ReconstructedGeometryTimeSpan</span><span class="o">.</span><span class="n">DefaultDeactivatePoints</span><span class="p">(</span>
            <span class="c1"># Choose our own parameters that are different than the defaults...</span>
            <span class="n">threshold_velocity_delta</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> <span class="c1"># cms/yr</span>
            <span class="n">threshold_distance_to_boundary</span> <span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="c1"># kms/myr</span>
            <span class="n">deactivate_points_that_fall_outside_a_network</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>You can also implement your own deactivation algorithm by implementing your own class that inherits from
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints" title="pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints</span></code></a> and overrides its
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints.deactivate" title="pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints.deactivate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">deactivate</span> <span class="pre">method</span></code></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is what the <em>default</em> deactivation algorithm does.
In other words, the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.DefaultDeactivatePoints" title="pygplates.ReconstructedGeometryTimeSpan.DefaultDeactivatePoints"><code class="xref py py-class docutils literal notranslate"><span class="pre">DefaultDeactivatePoints</span></code></a> class
inherits from the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints" title="pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeactivatePoints</span></code></a> class.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints" title="pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.DeactivatePoints</span></code></a> for more details.</p>
</div>
</section>
</section>
<section id="reconstructed-geometry-time-span">
<span id="pygplates-primer-reconstructed-geometry-time-span"></span><h5><a class="toc-backref" href="#id62" role="doc-backlink">Reconstructed geometry time span</a><a class="headerlink" href="#reconstructed-geometry-time-span" title="Link to this heading"></a></h5>
<p>A <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan" title="pygplates.ReconstructedGeometryTimeSpan"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan</span></code></a> contains a history of reconstruction snapshots generated by <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>.</p>
<p>Each snapshot stores the following quantities:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-velocities"><span class="std std-ref">Velocities</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-topology-locations"><span class="std std-ref">Topology locations</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-strain-rates"><span class="std std-ref">Strain rates</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-strains"><span class="std std-ref">Strains</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-scalar-values"><span class="std std-ref">Scalar values</span></a></p>
<ul>
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-crustal-thickness-factors"><span class="std std-ref">Crustal thickness factors</span></a></p></li>
<li><p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-tectonic-subsidence"><span class="std std-ref">Tectonic subsidence</span></a></p></li>
</ul>
</li>
</ul>
<p>The history of snapshots is stored in time slots defined by <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_time_span()</span></code></a> whose time range is
determined by the <em>oldest_time</em> and <em>youngest_time</em> arguments of <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>.
For example, to iterate over the <em>stored</em> history of <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">reconstructed geometry points</span></a>
(from oldest time to youngest time):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">oldest_time</span><span class="p">,</span> <span class="n">youngest_time</span><span class="p">,</span> <span class="n">time_increment</span><span class="p">,</span> <span class="n">num_time_slots</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_time_span</span><span class="p">()</span>
<span class="k">for</span> <span class="n">time_slot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_time_slots</span><span class="p">):</span>
   <span class="n">reconstruction_time</span> <span class="o">=</span> <span class="n">oldest_time</span> <span class="o">-</span> <span class="n">time_slot</span> <span class="o">*</span> <span class="n">time_increment</span>
   <span class="n">reconstructed_points</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_geometry_points</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>
</pre></div>
</div>
<p>However, you can query the snapshots at any <em>arbitrary</em> reconstruction time, it does not have to match a time slot.
And it can be outside the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of snapshots
(although typically you would generate a time range that contains all desired reconstruction times).
For times not matching a time slot, the behaviour is defined separately for each snapshot quantity.</p>
<p>For example, to iterate over the reconstructed geometry points at 1Myr intervals (from oldest time to youngest time)
<em>regardless</em> of the time slot intervals (which could be larger than 1Myr):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">oldest_time</span><span class="p">,</span> <span class="n">youngest_time</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_time_span</span><span class="p">()</span>
<span class="n">reconstruction_time</span> <span class="o">=</span> <span class="n">oldest_time</span>
<span class="k">while</span> <span class="n">reconstruction_time</span> <span class="o">&gt;=</span> <span class="n">youngest_time</span><span class="p">:</span>
   <span class="n">reconstructed_points</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_geometry_points</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>
   <span class="n">reconstruction_time</span> <span class="o">-=</span> <span class="mf">1.0</span>
</pre></div>
</div>
<p>When querying the various quantities in a snapshot (such as points or their velocities), each query has a <code class="docutils literal notranslate"><span class="pre">return_inactive_points</span></code> argument.
It defaults to <code class="docutils literal notranslate"><span class="pre">False</span></code> so that only quantities associated with <em>active</em> points are returned. However, if you set it to <code class="docutils literal notranslate"><span class="pre">True</span></code> then
quantities associated with both <em>active</em> and <em>inactive</em> points are returned. Each inactive point will have a value of <code class="docutils literal notranslate"><span class="pre">None</span></code>
(since quantities cannot be calculated at inactive points). This can be useful when you need to keep track of points and their quantities
over time, since you can use point indices (an integer index into an array of points) which is not possible otherwise. For example, to find the maximum
<a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-velocities"><span class="std std-ref">velocity</span></a> of each point (in a geometry) over the time range of the snapshots:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># The number of initial points in the geometry (initially all points are active).</span>
<span class="n">num_initial_points</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">initial_points</span><span class="p">)</span>

<span class="c1"># A NumPy array of zeros (one for each point).</span>
<span class="c1"># This will later get updated with the max velocity of each point (in the same order as the points).</span>
<span class="n">max_point_velocities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_initial_points</span><span class="p">)</span>

<span class="c1"># Topologically reconstruct the initial points from 100 Ma to present day (at 1 Myr intervals).</span>
<span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span><span class="n">initial_points</span><span class="p">,</span> <span class="n">initial_time</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

<span class="c1"># Iterate over the time slots (100, 99, ..., 1, 0 Ma).</span>
<span class="n">oldest_time</span><span class="p">,</span> <span class="n">youngest_time</span><span class="p">,</span> <span class="n">time_increment</span><span class="p">,</span> <span class="n">num_time_slots</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_time_span</span><span class="p">()</span>
<span class="k">for</span> <span class="n">time_slot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_time_slots</span><span class="p">):</span>
   <span class="n">reconstruction_time</span> <span class="o">=</span> <span class="n">oldest_time</span> <span class="o">-</span> <span class="n">time_slot</span> <span class="o">*</span> <span class="n">time_increment</span>

   <span class="c1"># Get the velocity at each point (for each inactive point it will be &#39;None&#39;).</span>
   <span class="n">reconstructed_velocities</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_velocities</span><span class="p">(</span>
         <span class="n">reconstruction_time</span><span class="p">,</span>
         <span class="n">return_inactive_points</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

   <span class="c1"># If all points are inactive (in the current time slot) then &#39;reconstructed_velocities&#39; itself will be &#39;None&#39;.</span>
   <span class="c1">#</span>
   <span class="c1"># Note: If it is &#39;None&#39; then you could potentially finish here (because once all points are deactivated</span>
   <span class="c1">#       they can&#39;t be reactivated). However this depends on the order you visit the time slots. It&#39;s only</span>
   <span class="c1">#       possible if you start at the initial time (slot) which in our case happens to be the oldest time</span>
   <span class="c1">#       (since we&#39;re reconstructing *forward* in time from 100 Ma to present day).</span>
   <span class="k">if</span> <span class="n">reconstructed_velocities</span><span class="p">:</span>
      <span class="c1"># Iterate over all the points (some might be inactive).</span>
      <span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_initial_points</span><span class="p">):</span>
         <span class="n">velocity</span> <span class="o">=</span> <span class="n">reconstructed_velocities</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
         <span class="c1"># If the current point is active (in the current time slot) then it will have a velocity.</span>
         <span class="k">if</span> <span class="n">velocity</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># See if velocity is the maximum for the current point over all time slots visited so far.</span>
            <span class="n">velocity_magnitude</span> <span class="o">=</span> <span class="n">velocity</span><span class="o">.</span><span class="n">get_magnitude</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">velocity_magnitude</span> <span class="o">&gt;</span> <span class="n">max_point_velocities</span><span class="p">[</span><span class="n">point_index</span><span class="p">]:</span>
               <span class="n">max_point_velocities</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity_magnitude</span>

<span class="c1"># Print out the maximum velocity of each geometry point.</span>
<span class="k">for</span> <span class="n">point_index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_initial_points</span><span class="p">):</span>
   <span class="n">lat</span><span class="p">,</span> <span class="n">lon</span> <span class="o">=</span> <span class="n">initial_points</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span><span class="o">.</span><span class="n">to_lat_lon</span><span class="p">()</span>
   <span class="n">velocity_magnitude</span> <span class="o">=</span> <span class="n">max_point_velocities</span><span class="p">[</span><span class="n">point_index</span><span class="p">]</span>
   <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Max velocity of point initially at lon/lat (</span><span class="si">{}</span><span class="s1">, </span><span class="si">{}</span><span class="s1">) is </span><span class="si">{}</span><span class="s1"> km/myr&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">lon</span><span class="p">,</span> <span class="n">lat</span><span class="p">,</span> <span class="n">velocity_magnitude</span><span class="p">))</span>
</pre></div>
</div>
<p>…where we’ve associated a (maximum) velocity with each initial geometry point (such that the maximum velocity, and initial position,
of any geometry point can be found using its <code class="docutils literal notranslate"><span class="pre">point_index</span></code>).</p>
<section id="geometry-points">
<span id="pygplates-primer-reconstructed-geometry-time-span-geometry-points"></span><h6><a class="toc-backref" href="#id63" role="doc-backlink">Geometry points</a><a class="headerlink" href="#geometry-points" title="Link to this heading"></a></h6>
<p>The reconstructed geometry points at a reconstruction time can be queried using <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_geometry_points" title="pygplates.ReconstructedGeometryTimeSpan.get_geometry_points"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_geometry_points()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_points</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_geometry_points</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_points</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>If the requested reconstruction time matches a time slot in the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">span</span></code></a> then
the geometry points of the snapshot in that time slot are returned.</p>
<p>If the requested reconstruction time is <em>within</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots,
but does not match a time slot, then the geometry points in the time slot (of the two time slots nearest the reconstruction time) that is closest
to the initial time (specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>) will be incrementally reconstructed (away from the initial time)
to the requested reconstruction time using <a class="reference internal" href="generated/pygplates.ResolvedTopologicalBoundary.html#pygplates.ResolvedTopologicalBoundary.reconstruct_point" title="pygplates.ResolvedTopologicalBoundary.reconstruct_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalBoundary.reconstruct_point()</span></code></a> or <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork.reconstruct_point" title="pygplates.ResolvedTopologicalNetwork.reconstruct_point"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalNetwork.reconstruct_point()</span></code></a>
(depending on which plate/network in the time slot each active point lies within). And those reconstructed points will be returned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned geometry points will have the same active status as the time slot they’re incrementally reconstructed <em>from</em>.
In other words, if a point is active in the source time slot then it’ll also be active in the returned geometry points.</p>
</div>
<p>If the requested reconstruction time is <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots then the
reconstruction plate ID specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a> will be used to <em>rigidly</em> reconstruct the geometry points from
the oldest time slot (if the requested reconstruction time is older), or from the youngest time slot (if the requested reconstruction time is younger),
to the requested reconstruction time. And those reconstructed points will be returned.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The active status of the returned points will be the same as those in the oldest or youngest time slot. Which means there can still be active geometry points
when the reconstruction time is <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If no reconstruction plate ID was specified then there will be no rigid rotation, and so the geometry points from the oldest or youngest time slot will
effectively be returned. However typically you would generate a time range that contains all desired reconstruction times (so this situation would not typically occur).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The reconstruction plate ID can also be used when the requested reconstruction time is <em>inside</em> the time range and some geometry points are
<em>outside</em> all resolved topologies (and hence cannot be reconstructed by the topologies). This can happen if the topologies are regional (instead of global)
or if there are cracks between adjacent topologies (due to the way they were built).</p>
</div>
<p>In all cases, if <em>none</em> of the geometry points are active at the reconstruction time then <code class="docutils literal notranslate"><span class="pre">None</span></code> will be returned.</p>
</section>
<section id="topology-locations">
<span id="pygplates-primer-reconstructed-geometry-time-span-topology-locations"></span><h6><a class="toc-backref" href="#id64" role="doc-backlink">Topology locations</a><a class="headerlink" href="#topology-locations" title="Link to this heading"></a></h6>
<p>A <a class="reference internal" href="generated/pygplates.TopologyPointLocation.html#pygplates.TopologyPointLocation" title="pygplates.TopologyPointLocation"><code class="xref py py-class docutils literal notranslate"><span class="pre">topology</span> <span class="pre">location</span></code></a> identifies the resolved topology boundary or network that contains a reconstructed geometry point,
or identifies no resolved topologies if the point does not intersect any.</p>
<p>The topology location of each reconstructed geometry point at a reconstruction time can be queried using <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_topology_point_locations" title="pygplates.ReconstructedGeometryTimeSpan.get_topology_point_locations"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_topology_point_locations()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_topology_locations</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_topology_point_locations</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_topology_locations</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>A topology location is returned for each geometry point that is <em>active at the requested reconstruction time</em>
(see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a>). If <em>none</em> of the points are active then <code class="docutils literal notranslate"><span class="pre">None</span></code> will be returned.</p>
<p>If the requested reconstruction time is <em>within</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots
then the returned topology locations are those of the geometry points in the time slot (of the two time slots nearest the reconstruction time)
that is closest to the initial time (specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The topology locations are at the time of the time slot (rather than the reconstruction time) because topologies are only resolved at the time slots.</p>
</div>
<p>If the requested reconstruction time is <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots then the returned
topology locations identify no resolved topologies. In other words, <a class="reference internal" href="generated/pygplates.TopologyPointLocation.html#pygplates.TopologyPointLocation.not_located_in_resolved_topology" title="pygplates.TopologyPointLocation.not_located_in_resolved_topology"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologyPointLocation.not_located_in_resolved_topology()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">True</span></code>
for each geometry point. This is because topologies are <em>not</em> resolved outside the time range.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="generated/pygplates.ResolvedTopologicalBoundary.html#pygplates.ResolvedTopologicalBoundary.get_point_location" title="pygplates.ResolvedTopologicalBoundary.get_point_location"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalBoundary.get_point_location()</span></code></a> and <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork.get_point_location" title="pygplates.ResolvedTopologicalNetwork.get_point_location"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalNetwork.get_point_location()</span></code></a></p>
</div>
</section>
<section id="velocities">
<span id="pygplates-primer-reconstructed-geometry-time-span-velocities"></span><h6><a class="toc-backref" href="#id65" role="doc-backlink">Velocities</a><a class="headerlink" href="#velocities" title="Link to this heading"></a></h6>
<p>The velocities of reconstructed geometry points at a reconstruction time can be queried using <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_velocities" title="pygplates.ReconstructedGeometryTimeSpan.get_velocities"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_velocities()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_velocities</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_velocities</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_velocities</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>A velocity is calculated for each geometry point that is <em>active at the requested reconstruction time</em>
(see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a>). If <em>none</em> of the points are active then <code class="docutils literal notranslate"><span class="pre">None</span></code> will be returned.</p>
<p>If the requested reconstruction time is <em>within</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots
then the returned velocities are calculated at the geometry points in the time slot (of the two time slots nearest the reconstruction time)
that is closest to the initial time (specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The velocities are calculated at the time of the time slot (rather than the reconstruction time), and at the positions of the active geometry points
in the time slot (rather than the geometry points at the reconstruction time - see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a>).
So, this is more like a nearest neighbour interpolation (rather than a linear interpolation) of the two nearest time slots.
This is done since velocities are calculated using topologies, which are only resolved at the time slots, and the active status of velocities
needs to be synchronised with the geometry points.</p>
</div>
<p>The velocities are determined by the topologies (rigid plates and deforming networks) resolved at the time of the time slot using
<a class="reference internal" href="generated/pygplates.ResolvedTopologicalBoundary.html#pygplates.ResolvedTopologicalBoundary.get_point_velocity" title="pygplates.ResolvedTopologicalBoundary.get_point_velocity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalBoundary.get_point_velocity()</span></code></a> or <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork.get_point_velocity" title="pygplates.ResolvedTopologicalNetwork.get_point_velocity"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalNetwork.get_point_velocity()</span></code></a>
(depending on which plate/network in the time slot each active point lies within).</p>
<p>If the requested reconstruction time is <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots then the
returned velocities are determined by the reconstruction plate ID specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>, and they’re calculated
at the positions of the active geometry points at the reconstruction time (see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If no reconstruction plate ID was specified then the velocities will be zero.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The reconstruction plate ID can also be used when the requested reconstruction time is <em>inside</em> the time range and some geometry points are
<em>outside</em> all resolved topologies (and hence their velocities cannot be determined by the topologies). This can happen if the topologies are regional
(instead of global) or if there are cracks between adjacent topologies (due to the way they were built).</p>
</div>
</section>
<section id="strain-rates">
<span id="pygplates-primer-reconstructed-geometry-time-span-strain-rates"></span><h6><a class="toc-backref" href="#id66" role="doc-backlink">Strain rates</a><a class="headerlink" href="#strain-rates" title="Link to this heading"></a></h6>
<p>The <a class="reference internal" href="generated/pygplates.StrainRate.html#pygplates.StrainRate" title="pygplates.StrainRate"><code class="xref py py-class docutils literal notranslate"><span class="pre">strain</span> <span class="pre">rates</span></code></a> of reconstructed geometry points at a reconstruction time can be queried using
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_strain_rates" title="pygplates.ReconstructedGeometryTimeSpan.get_strain_rates"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_strain_rates()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_strain_rates</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_strain_rates</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_strain_rates</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>A strain rate is returned for each geometry point that is <em>active at the requested reconstruction time</em>
(see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a>). If <em>none</em> of the points are active then <code class="docutils literal notranslate"><span class="pre">None</span></code> will be returned.</p>
<p>If the requested reconstruction time is <em>within</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots
then the returned strain rates are interpolated between the two time slots nearest the reconstruction time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The time slot <em>further</em> from the initial time (specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>) might have deactivated
some points from the time slot <em>closer</em> to the initial time (see <a class="reference internal" href="#pygplates-primer-what-is-topological-reconstruction-deactivating-points"><span class="std std-ref">Deactivating points</span></a>).
For these points the strain rate is not interpolated (instead it’s obtained from the time slot <em>closer</em> to the initial time).</p>
</div>
<p>The strain rates in time slots are determined by the topologies (rigid plates and deforming networks) resolved at the time of the time slot using
<a class="reference internal" href="generated/pygplates.ResolvedTopologicalBoundary.html#pygplates.ResolvedTopologicalBoundary.get_point_strain_rate" title="pygplates.ResolvedTopologicalBoundary.get_point_strain_rate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalBoundary.get_point_strain_rate()</span></code></a> or <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork.get_point_strain_rate" title="pygplates.ResolvedTopologicalNetwork.get_point_strain_rate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalNetwork.get_point_strain_rate()</span></code></a>
(depending on which plate/network in the time slot each active point lies within). And the strain rate will be zero for each geometry point (in a time slot)
that is <em>not</em> within a deforming network.</p>
<p>If the requested reconstruction time is <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots then the
returned strain rates will be zero (no deformation).</p>
</section>
<section id="strains">
<span id="pygplates-primer-reconstructed-geometry-time-span-strains"></span><h6><a class="toc-backref" href="#id67" role="doc-backlink">Strains</a><a class="headerlink" href="#strains" title="Link to this heading"></a></h6>
<p>The <a class="reference internal" href="generated/pygplates.Strain.html#pygplates.Strain" title="pygplates.Strain"><code class="xref py py-class docutils literal notranslate"><span class="pre">strains</span></code></a> of reconstructed geometry points at a reconstruction time can be queried using
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_strains" title="pygplates.ReconstructedGeometryTimeSpan.get_strains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_strains()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_strains</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_strains</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_strains</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<p>A strain is returned for each geometry point that is <em>active at the requested reconstruction time</em>
(see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a>). If <em>none</em> of the points are active then <code class="docutils literal notranslate"><span class="pre">None</span></code> will be returned.</p>
<p>If the requested reconstruction time is <em>within</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots
then the returned strains are interpolated between the two time slots nearest the reconstruction time.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The time slot <em>further</em> from the initial time (specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>) might have deactivated
some points from the time slot <em>closer</em> to the initial time (see <a class="reference internal" href="#pygplates-primer-what-is-topological-reconstruction-deactivating-points"><span class="std std-ref">Deactivating points</span></a>).
For these points the strain is not interpolated (instead it’s obtained from the time slot <em>closer</em> to the initial time).</p>
</div>
<p>The strain of each geometry point is generated (in the time slots) by accumulating its strain rates <em>forward</em> in time, over the
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots, using <a class="reference internal" href="generated/pygplates.Strain.html#pygplates.Strain.accumulate" title="pygplates.Strain.accumulate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.Strain.accumulate()</span></code></a>.
The initial strain of each active geometry point in the oldest time slot will be the <em>identity</em> strain (since deformation has not yet occurred).
And the accumulated strain of a geometry point will only change (going forward in time) if the point undergoes deformation
(ie, is in a deforming network in one or more time slots).</p>
<p>If the requested reconstruction time is <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots then the
returned strains will be identity strains (no deformation) if the requested reconstruction time is older than the oldest time slot, and will be the
accumulated strains of the youngest time slot if the requested reconstruction time is younger than the youngest time slot (since strains do not accumulate
outside the time range of the snapshots because strain rates are zero there).</p>
</section>
<section id="scalar-values">
<span id="pygplates-primer-reconstructed-geometry-time-span-scalar-values"></span><h6><a class="toc-backref" href="#id68" role="doc-backlink">Scalar values</a><a class="headerlink" href="#scalar-values" title="Link to this heading"></a></h6>
<p>Each geometry point can have one or more scalar values.
And each scalar value (per point) is associated with a <a class="reference internal" href="generated/pygplates.ScalarType.html#pygplates.ScalarType" title="pygplates.ScalarType"><code class="xref py py-class docutils literal notranslate"><span class="pre">scalar</span> <span class="pre">type</span></code></a>.</p>
<p>Each scalar <em>type</em> belongs to one of two categories:</p>
<ul>
<li><p><em>Built-in scalar types</em>: whose scalar values <em>change</em> over time due to deformation</p>
<p>These are:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pygplates.ScalarType.gpml_crustal_thickness</span></code> - see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-crustal-thickness-factors"><span class="std std-ref">Crustal thickness factors</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pygplates.ScalarType.gpml_crustal_stretching_factor</span></code> - see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-crustal-thickness-factors"><span class="std std-ref">Crustal thickness factors</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pygplates.ScalarType.gpml_crustal_thinning_factor</span></code> - see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-crustal-thickness-factors"><span class="std std-ref">Crustal thickness factors</span></a></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pygplates.ScalarType.gpml_tectonic_subsidence</span></code> - see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-tectonic-subsidence"><span class="std std-ref">Tectonic subsidence</span></a></p></li>
</ul>
<p>Scalar values for these scalar types are always available.</p>
<p>And their initial scalar values have default values (at the initial time).
Hence the <em>initial_scalars</em> argument of <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a> does not need to be specified.</p>
</li>
<li><p><em>User-defined scalar types</em>: whose scalar values are <em>constant</em> over time</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Even though these scalar values are constant (over time) they still get deactivated when their associated
geometry points get deactivated.</p>
</div>
<p>These can be any <a class="reference internal" href="generated/pygplates.ScalarType.html#pygplates.ScalarType" title="pygplates.ScalarType"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ScalarType</span></code></a> that you define.
They are simply a way to associate your own data with the reconstructed geometry points.</p>
<p>Scalar values for these scalar types are <em>only</em> available if you define them
(using the <em>initial_scalars</em> argument of <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>).
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define your own scalar types.</span>
<span class="n">my_scalar_type_0</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s1">&#39;MyScalarType_0&#39;</span><span class="p">)</span>
<span class="n">my_scalar_type_1</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">create_gpml</span><span class="p">(</span><span class="s1">&#39;MyScalarType_1&#39;</span><span class="p">)</span>

<span class="c1"># Define associated scalar values (one per geometry point per scalar type).</span>
<span class="n">my_scalar_type_0_values</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
<span class="n">my_scalar_type_1_values</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">initial_points</span><span class="p">,</span>
      <span class="n">initial_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
      <span class="c1"># dict with two entries (each entry mapping a scalar type to its scalar values)...</span>
      <span class="n">initial_scalars</span> <span class="o">=</span> <span class="p">{</span> <span class="n">my_scalar_type_0</span> <span class="p">:</span> <span class="n">my_scalar_type_0_values</span><span class="p">,</span> <span class="n">my_scalar_type_1</span> <span class="p">:</span> <span class="n">my_scalar_type_1_values</span> <span class="p">})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <em>built-in scalar types</em> are still available when <em>user-defined scalar types</em> are defined.</p>
</div>
</li>
</ul>
<p>The scalar values of each reconstructed geometry point at a reconstruction time can be queried using
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_scalar_values" title="pygplates.ReconstructedGeometryTimeSpan.get_scalar_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_scalar_values()</span></code></a>. By default this will return a <code class="docutils literal notranslate"><span class="pre">dict</span></code> mapping <em>all</em> scalar types
(built-in and any user-defined) to their scalar values. For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get all active scalar values (associated with all built-in and user-defined scalar types).</span>
<span class="n">active_scalar_values</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_scalar_values</span><span class="p">(</span><span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">active_scalar_values</span><span class="p">:</span>

   <span class="c1"># Extract the scalar values associated with the built-in scalar types.</span>
   <span class="n">crustal_thicknesses_in_kms</span> <span class="o">=</span> <span class="n">active_scalar_values</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_thickness</span><span class="p">]</span>
   <span class="n">crustal_stretching_factors</span> <span class="o">=</span> <span class="n">active_scalar_values</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_stretching_factor</span><span class="p">]</span>
   <span class="n">crustal_thinning_factors</span> <span class="o">=</span> <span class="n">active_scalar_values</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_thinning_factor</span><span class="p">]</span>
   <span class="n">tectonic_subsidences</span> <span class="o">=</span> <span class="n">active_scalar_values</span><span class="p">[</span><span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_tectonic_subsidence</span><span class="p">]</span>

   <span class="c1"># Extract the scalar values associated with the user-defined scalar types.</span>
   <span class="n">my_active_scalar_values_0</span> <span class="o">=</span> <span class="n">active_scalar_values</span><span class="p">[</span><span class="n">my_scalar_type_0</span><span class="p">]</span>
   <span class="n">my_active_scalar_values_1</span> <span class="o">=</span> <span class="n">active_scalar_values</span><span class="p">[</span><span class="n">my_scalar_type_1</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Alternatively, you can specify a scalar type directly to <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_scalar_values" title="pygplates.ReconstructedGeometryTimeSpan.get_scalar_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_scalar_values()</span></code></a>.
For example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">my_active_scalar_values_0</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_scalar_values</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">,</span>
      <span class="n">my_scalar_type_0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>A scalar value (per scalar type) is returned for each geometry point that is <em>active at the requested reconstruction time</em>
(see <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-geometry-points"><span class="std std-ref">Geometry points</span></a>). If <em>none</em> of the points are active then <code class="docutils literal notranslate"><span class="pre">None</span></code> will be returned.</p>
<p>If the requested reconstruction time is <em>within</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots
then the returned scalar values are those of the geometry points in the time slot (of the two time slots nearest the reconstruction time)
that is closest to the initial time (specified in <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is at the time of the time slot (rather than the reconstruction time), so this is more like a nearest neighbour interpolation
(rather than a linear interpolation) of the two nearest time slots. This only matters for built-in scalar types since user-defined
scalar types are constant over time.</p>
</div>
<p>If the requested reconstruction time is <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots then the
returned scalar values will be from the oldest time slot (if the requested reconstruction time is older) or from the youngest time slot
(if the requested reconstruction time is younger).</p>
</section>
<section id="crustal-thickness-factors">
<span id="pygplates-primer-reconstructed-geometry-time-span-crustal-thickness-factors"></span><h6><a class="toc-backref" href="#id69" role="doc-backlink">Crustal thickness factors</a><a class="headerlink" href="#crustal-thickness-factors" title="Link to this heading"></a></h6>
<p>The crustal thickness factor <span class="math notranslate nohighlight">\(F(t) = \frac{T(t)}{T(t_{initial})}\)</span> measures the ratio of the crustal thickness
at a reconstruction time <span class="math notranslate nohighlight">\(T(t)\)</span> to the initial crustal thickness at the initial time <span class="math notranslate nohighlight">\(T(t_{initial})\)</span>.
It is only calculated internally, and always has a value of <code class="docutils literal notranslate"><span class="pre">1.0</span></code> at the initial time (<span class="math notranslate nohighlight">\(F(t_{initial}) = 1.0\)</span>).</p>
<p>Publicly, there are three built-in <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-scalar-values"><span class="std std-ref">scalar values</span></a>
that depend on the internal crustal thickness factor <span class="math notranslate nohighlight">\(F(t)\)</span>:</p>
<ul>
<li><p><em>Crustal thickness</em> (in kms): <span class="math notranslate nohighlight">\(T(t)\)</span></p>
<p>The crustal thickness is calculated as:</p>
<p><span class="math notranslate nohighlight">\(T(t) = F(t) \, T(t_{initial})\)</span></p>
<p>By default, the initial crustal thickness <span class="math notranslate nohighlight">\(T(t_{initial})\)</span> is <code class="docutils literal notranslate"><span class="pre">40</span></code> kms.
But you can specify a different value for each initial geometry point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify one initial crustal thickness (in kms) per initial point.</span>
<span class="n">initial_crustal_thicknesses_in_kms</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">initial_points</span><span class="p">,</span>
      <span class="n">initial_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
      <span class="c1"># dict with a single entry that maps the crustal thickness scalar type to initial values...</span>
      <span class="n">initial_scalars</span> <span class="o">=</span> <span class="p">{</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_thickness</span> <span class="p">:</span> <span class="n">initial_crustal_thicknesses_in_kms</span> <span class="p">})</span>
</pre></div>
</div>
<p>The crustal thicknesses can be queried at any reconstruction time using
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_crustal_thicknesses" title="pygplates.ReconstructedGeometryTimeSpan.get_crustal_thicknesses"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_crustal_thicknesses()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_crustal_thicknesses_in_kms</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_crustal_thicknesses</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_crustal_thicknesses_in_kms</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the equivalent of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_crustal_thicknesses_in_kms</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_scalar_values</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">,</span>
      <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_thickness</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
</li>
<li><p><em>Crustal stretching factor</em>: <span class="math notranslate nohighlight">\(\beta(t) = \frac{T(t_{initial})}{T(t)}\)</span></p>
<p>By default, the initial crustal stretching factor <span class="math notranslate nohighlight">\(\beta(t_{initial})\)</span> is <code class="docutils literal notranslate"><span class="pre">1</span></code>.
And so the crustal stretching factor is calculated as:</p>
<p><span class="math notranslate nohighlight">\(\beta(t) = \frac{1}{F(t)}\)</span></p>
<p>But you can specify a different <span class="math notranslate nohighlight">\(\beta(t_{initial})\)</span> value for <em>each</em> initial geometry point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify one initial crustal stretching factor per initial point.</span>
<span class="n">initial_crustal_stretching_factors</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">initial_points</span><span class="p">,</span>
      <span class="n">initial_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
      <span class="c1"># dict with a single entry that maps the crustal stretching factor scalar type to initial values...</span>
      <span class="n">initial_scalars</span> <span class="o">=</span> <span class="p">{</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_stretching_factor</span> <span class="p">:</span> <span class="n">initial_crustal_stretching_factors</span> <span class="p">})</span>
</pre></div>
</div>
<p>…where each crustal stretching factor is then calculated as:</p>
<p><span class="math notranslate nohighlight">\(\beta(t) = \frac{\beta(t_{initial})}{F(t)}\)</span></p>
<p>The crustal stretching factors can be queried at any reconstruction time using
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_crustal_stretching_factors" title="pygplates.ReconstructedGeometryTimeSpan.get_crustal_stretching_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_crustal_stretching_factors()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_crustal_stretching_factors</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_crustal_stretching_factors</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_crustal_stretching_factors</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the equivalent of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_crustal_stretching_factors</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_scalar_values</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">,</span>
      <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_stretching_factor</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
</li>
<li><p><em>Crustal thinning factor</em>: <span class="math notranslate nohighlight">\(\gamma(t) = 1 - \frac{T(t)}{T(t_{initial})}\)</span></p>
<p>By default, the initial crustal thinning factor <span class="math notranslate nohighlight">\(\gamma(t_{initial})\)</span> is <code class="docutils literal notranslate"><span class="pre">0</span></code>.
And so the crustal thinning factor is calculated as:</p>
<p><span class="math notranslate nohighlight">\(\gamma(t) = 1 - F(t)\)</span></p>
<p>But you can specify a different <span class="math notranslate nohighlight">\(\gamma(t_{initial})\)</span> value for <em>each</em> initial geometry point:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify one initial crustal thinning factor per initial point.</span>
<span class="n">initial_crustal_thinning_factors</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">initial_points</span><span class="p">,</span>
      <span class="n">initial_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
      <span class="c1"># dict with a single entry that maps the crustal thinning factor scalar type to initial values...</span>
      <span class="n">initial_scalars</span> <span class="o">=</span> <span class="p">{</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_thinning_factor</span> <span class="p">:</span> <span class="n">initial_crustal_thinning_factors</span> <span class="p">})</span>
</pre></div>
</div>
<p>…where each crustal thinning factor is then calculated as:</p>
<p><span class="math notranslate nohighlight">\(\gamma(t) = 1 - (1 - \gamma(t_{initial})) \, F(t)\)</span></p>
<p>The crustal thinning factors can be queried at any reconstruction time using
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_crustal_thinning_factors" title="pygplates.ReconstructedGeometryTimeSpan.get_crustal_thinning_factors"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_crustal_thinning_factors()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_crustal_thinning_factors</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_crustal_thinning_factors</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_crustal_thinning_factors</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the equivalent of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_crustal_thinning_factors</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_scalar_values</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">,</span>
      <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_crustal_thinning_factor</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
</li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-scalar-values"><span class="std std-ref">Scalar values</span></a>, for more details on how scalar values are queried when the
requested reconstruction time is <em>inside</em> or <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots.</p>
</div>
</section>
<section id="tectonic-subsidence">
<span id="pygplates-primer-reconstructed-geometry-time-span-tectonic-subsidence"></span><h6><a class="toc-backref" href="#id70" role="doc-backlink">Tectonic subsidence</a><a class="headerlink" href="#tectonic-subsidence" title="Link to this heading"></a></h6>
<p>Tectonic subsidence is one of the built-in <a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-scalar-values"><span class="std std-ref">scalar values</span></a> that evolves over time due to deformation.
By default, the initial tectonic subsidence (at the initial time) is zero for each geometry point.
However you can optionally specify your own initial tectonic subsidence values (using the <em>initial_scalars</em> argument of <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel.reconstruct_geometry" title="pygplates.TopologicalModel.reconstruct_geometry"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.TopologicalModel.reconstruct_geometry()</span></code></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Specify one initial tectonic subsidence value (in kms) per initial point.</span>
<span class="n">initial_tectonic_subsidences_in_kms</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>

<span class="n">reconstructed_geometry_time_span</span> <span class="o">=</span> <span class="n">topological_model</span><span class="o">.</span><span class="n">reconstruct_geometry</span><span class="p">(</span>
      <span class="n">initial_points</span><span class="p">,</span>
      <span class="n">initial_time</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
      <span class="c1"># dict with a single entry that maps the tectonic subsidence scalar type to initial values...</span>
      <span class="n">initial_scalars</span> <span class="o">=</span> <span class="p">{</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_tectonic_subsidence</span> <span class="p">:</span> <span class="n">initial_tectonic_subsidences_in_kms</span> <span class="p">})</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default (zero tectonic subsidence at the initial time) does not require the <code class="docutils literal notranslate"><span class="pre">initial_scalars</span></code> argument to be specified.</p>
</div>
<p>The tectonic subsidence of each reconstructed geometry point at any reconstruction time can then be queried using
<a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_tectonic_subsidences" title="pygplates.ReconstructedGeometryTimeSpan.get_tectonic_subsidences"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_tectonic_subsidences()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_tectonic_subsidences_in_kms</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_tectonic_subsidences</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">)</span>

<span class="c1"># If none of the points are active at &#39;reconstruction_time&#39; then this will be &#39;None&#39;.</span>
<span class="k">if</span> <span class="n">reconstructed_tectonic_subsidences_in_kms</span><span class="p">:</span>
   <span class="o">...</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is the equivalent of:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_tectonic_subsidences_in_kms</span> <span class="o">=</span> <span class="n">reconstructed_geometry_time_span</span><span class="o">.</span><span class="n">get_scalar_values</span><span class="p">(</span>
      <span class="n">reconstruction_time</span><span class="p">,</span>
      <span class="n">pygplates</span><span class="o">.</span><span class="n">ScalarType</span><span class="o">.</span><span class="n">gpml_tectonic_subsidence</span><span class="p">)</span>
<span class="o">...</span>
</pre></div>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pygplates-primer-reconstructed-geometry-time-span-scalar-values"><span class="std std-ref">Scalar values</span></a>, for more details on how scalar values are queried when the
requested reconstruction time is <em>inside</em> or <em>outside</em> the <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_time_span" title="pygplates.ReconstructedGeometryTimeSpan.get_time_span"><code class="xref py py-meth docutils literal notranslate"><span class="pre">time</span> <span class="pre">range</span></code></a> of the snapshots.</p>
</div>
</section>
</section>
</section>
</section>
</section>
<section id="deformation">
<span id="pygplates-primer-deformation"></span><h2><a class="toc-backref" href="#id23" role="doc-backlink">Deformation</a><a class="headerlink" href="#deformation" title="Link to this heading"></a></h2>
<p>This section covers deformation in pyGPlates.</p>
<nav class="contents local" id="id5">
<ul class="simple">
<li><p><a class="reference internal" href="#topological-network" id="id71">Topological network</a></p></li>
<li><p><a class="reference internal" href="#rigid-blocks" id="id72">Rigid blocks</a></p></li>
<li><p><a class="reference internal" href="#network-triangulation" id="id73">Network triangulation</a></p></li>
<li><p><a class="reference internal" href="#strain-rates-in-triangulation" id="id74">Strain rates in triangulation</a></p>
<ul>
<li><p><a class="reference internal" href="#strain-rate-clamping" id="id75">Strain rate clamping</a></p></li>
<li><p><a class="reference internal" href="#strain-rate-smoothing" id="id76">Strain rate smoothing</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#exponential-rift-stretching-profile" id="id77">Exponential rift stretching profile</a></p>
<ul>
<li><p><a class="reference internal" href="#rift-left-right-plate-ids" id="id78">Rift left/right plate IDs</a></p></li>
<li><p><a class="reference internal" href="#rift-exponential-stretching-constant" id="id79">Rift exponential stretching constant</a></p></li>
<li><p><a class="reference internal" href="#rift-strain-rate-resolution" id="id80">Rift strain rate resolution</a></p></li>
<li><p><a class="reference internal" href="#rift-edge-length-threshold" id="id81">Rift edge length threshold</a></p></li>
</ul>
</li>
</ul>
</nav>
<section id="topological-network">
<span id="pygplates-primer-topological-network"></span><h3><a class="toc-backref" href="#id71" role="doc-backlink">Topological network</a><a class="headerlink" href="#topological-network" title="Link to this heading"></a></h3>
<p>To model deformation, a topological network must first be created. This consists of a boundary polygon
(resolved by intersecting boundary line segments, similar to topological closed plate polygons), optional interior rigid blocks,
individual deforming points, and a triangulation (with vertices from boundary, rigid blocks and deforming points).</p>
<figure class="align-default" id="id6">
<img alt="_images/DeformingNetworkDiagram.png" src="_images/DeformingNetworkDiagram.png" />
<figcaption>
<p><span class="caption-text">On the left are the elements that make up a topological network.
On the right is the resolving of these elements at a reconstruction time to form a resolved topological network.</span><a class="headerlink" href="#id6" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>More information on topological networks in GPlates/pyGPlates can be found in the following paper:</p>
<ul class="simple">
<li><p>Michael Gurnis, Ting Yang, John Cannon, Mark Turner, Simon Williams, Nicolas Flament, R. Dietmar Müller, 2018,
<a class="reference external" href="https://doi.org/10.1016/j.cageo.2018.04.007">Global tectonic reconstructions with continuously deforming and evolving rigid plates</a>,
<strong>Computers &amp; Geosciences,</strong> 116, 32-41, doi: 10.1016/j.cageo.2018.04.007</p></li>
</ul>
</section>
<section id="rigid-blocks">
<span id="pygplates-primer-rigid-blocks"></span><h3><a class="toc-backref" href="#id72" role="doc-backlink">Rigid blocks</a><a class="headerlink" href="#rigid-blocks" title="Link to this heading"></a></h3>
<p>A topological network can <em>optionally</em> have interior islands that are rigid.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Any <a class="reference internal" href="generated/pygplates.GpmlTopologicalSection.html#pygplates.GpmlTopologicalSection.create_network_interior" title="pygplates.GpmlTopologicalSection.create_network_interior"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interior</span> <span class="pre">geometry</span> <span class="pre">of</span> <span class="pre">a</span> <span class="pre">network</span></code></a> that is a <em>polygon</em> is considered a rigid block.
And the <em>interior</em> rings (if any) of a rigid block polygon are ignored (ie, only the exterior ring applies).</p>
</div>
<p>Each rigid block is represented by a <a class="reference internal" href="generated/pygplates.ReconstructedFeatureGeometry.html#pygplates.ReconstructedFeatureGeometry" title="pygplates.ReconstructedFeatureGeometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ReconstructedFeatureGeometry</span></code></a>, and is obtained from a <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork" title="pygplates.ResolvedTopologicalNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalNetwork</span></code></a> with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rigid_blocks</span> <span class="o">=</span> <span class="n">resolved_topological_network</span><span class="o">.</span><span class="n">get_rigid_blocks</span><span class="p">()</span>
</pre></div>
</div>
<p>For example, you can get the plate ID and boundary polygon of each interior rigid block (if any):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">rigid_block</span> <span class="ow">in</span> <span class="n">rigid_blocks</span><span class="p">:</span>
    <span class="n">rigid_block_plate_id</span> <span class="o">=</span> <span class="n">rigid_block</span><span class="o">.</span><span class="n">get_feature</span><span class="p">()</span><span class="o">.</span><span class="n">get_reconstruction_plate_id</span><span class="p">()</span>
    <span class="n">rigid_block_boundary</span> <span class="o">=</span> <span class="n">rigid_block</span><span class="o">.</span><span class="n">get_reconstructed_geometry</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="network-triangulation">
<span id="pygplates-primer-network-triangulation"></span><h3><a class="toc-backref" href="#id73" role="doc-backlink">Network triangulation</a><a class="headerlink" href="#network-triangulation" title="Link to this heading"></a></h3>
<p>The network triangulation of a <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork" title="pygplates.ResolvedTopologicalNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">resolved</span> <span class="pre">topological</span> <span class="pre">network</span></code></a> is the Delaunay triangulation of vertices
obtained from the network’s boundary (polygon) and any interior rigid blocks (polygons) and any interior geometries (points or lines).</p>
<p>The Delaunay triangulation is a triangulation of the <em>convex hull</em> of its vertices. So it includes triangles <em>outside</em> the network boundary
(and also includes triangles <em>inside</em> any interior rigid blocks). However, the deforming region of a network is defined to be <em>inside</em> the
network’s boundary polygon (but <em>outside</em> its interior rigid block polygons, if any). Hence the triangulation contains triangles that are <em>outside</em>
the deforming region. Therefore each triangle has a <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle.is_in_deforming_region" title="pygplates.NetworkTriangulation.Triangle.is_in_deforming_region"><code class="xref py py-attr docutils literal notranslate"><span class="pre">flag</span></code></a> indicating whether
it is inside the deforming region (if it’s centroid is in the deforming region) or not. These triangles in the deforming region of a network triangulation
are referred to as the <em>deforming triangulation</em>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The Delaunay triangulation is not a <em>constrained</em> triangulation. This means the edges of some Delaunay triangles can cross over network boundary edges or
interior block edges, rather than be constrained to follow them. However the flagging of Delaunay triangles (as deforming or non-deforming) deals with this
quite effectively for current topological network datasets.</p>
</div>
<p>The <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle.is_in_deforming_region" title="pygplates.NetworkTriangulation.Triangle.is_in_deforming_region"><code class="xref py py-attr docutils literal notranslate"><span class="pre">deforming</span></code></a> triangles in a network triangulation do not overlap any
<a class="reference internal" href="#pygplates-primer-rigid-blocks"><span class="std std-ref">interior rigid blocks</span></a> (other than the above-mentioned note about <em>constrained</em> triangulations).
In other words, the <em>deforming</em> triangles (in the network triangulation) represent the <em>deforming</em> region of a
<a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork" title="pygplates.ResolvedTopologicalNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">resolved</span> <span class="pre">topological</span> <span class="pre">network</span></code></a> and the rigid blocks (if any) represent the <em>rigid</em> regions.</p>
<p>A network triangulation is represented by a <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation" title="pygplates.NetworkTriangulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.NetworkTriangulation</span></code></a>, and is obtained from a <a class="reference internal" href="generated/pygplates.ResolvedTopologicalNetwork.html#pygplates.ResolvedTopologicalNetwork" title="pygplates.ResolvedTopologicalNetwork"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ResolvedTopologicalNetwork</span></code></a> with:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">network_triangulation</span> <span class="o">=</span> <span class="n">resolved_topological_network</span><span class="o">.</span><span class="n">get_network_triangulation</span><span class="p">()</span>
</pre></div>
</div>
<p>It consists of a sequence of vertices and a sequence of triangles. Each vertex is represented by a <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Vertex" title="pygplates.NetworkTriangulation.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.NetworkTriangulation.Vertex</span></code></a> and contains a position,
a velocity, and a strain rate, and a list of incident vertices and incident triangles. Each triangle is represented by a <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle" title="pygplates.NetworkTriangulation.Triangle"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.NetworkTriangulation.Triangle</span></code></a>
and contains a flag indicating whether it’s deforming or not, and contains a strain rate, and references three vertices and three adjacent triangles.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">triangles</span> <span class="o">=</span> <span class="n">network_triangulation</span><span class="o">.</span><span class="n">get_triangles</span><span class="p">()</span>
<span class="n">vertices</span> <span class="o">=</span> <span class="n">network_triangulation</span><span class="o">.</span><span class="n">get_vertices</span><span class="p">()</span>

<span class="k">for</span> <span class="n">triangle</span> <span class="ow">in</span> <span class="n">triangles</span><span class="p">:</span>
   <span class="n">triangle_is_in_deforming_region</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">is_in_deforming_region</span>
   <span class="n">triangle_strain_rate</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">strain_rate</span>

   <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
      <span class="n">triangle_vertex</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
      <span class="n">adjacent_triangle</span> <span class="o">=</span> <span class="n">triangle</span><span class="o">.</span><span class="n">get_adjacent_triangle</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
      <span class="k">if</span> <span class="n">adjacent_triangle</span><span class="p">:</span>  <span class="c1"># if not at a triangulation boundary</span>
         <span class="o">...</span>

<span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>
   <span class="n">vertex_position</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">position</span>
   <span class="n">vertex_strain_rate</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">strain_rate</span>
   <span class="n">vertex_velocity</span> <span class="o">=</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_velocity</span><span class="p">()</span>  <span class="c1"># a function optionally accepting various velocity calculation parameters</span>

   <span class="k">for</span> <span class="n">incident_vertex</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_incident_vertices</span><span class="p">():</span>
      <span class="o">...</span>
   <span class="k">for</span> <span class="n">incident_triangle</span> <span class="ow">in</span> <span class="n">vertex</span><span class="o">.</span><span class="n">get_incident_triangles</span><span class="p">():</span>
      <span class="o">...</span>
</pre></div>
</div>
</section>
<section id="strain-rates-in-triangulation">
<span id="pygplates-primer-strain-rates-in-triangulation"></span><h3><a class="toc-backref" href="#id74" role="doc-backlink">Strain rates in triangulation</a><a class="headerlink" href="#strain-rates-in-triangulation" title="Link to this heading"></a></h3>
<p>Each <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle" title="pygplates.NetworkTriangulation.Triangle"><code class="xref py py-class docutils literal notranslate"><span class="pre">triangle</span></code></a> in a <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation" title="pygplates.NetworkTriangulation"><code class="xref py py-class docutils literal notranslate"><span class="pre">network</span> <span class="pre">triangulation</span></code></a> is assigned a <a class="reference internal" href="generated/pygplates.StrainRate.html#pygplates.StrainRate" title="pygplates.StrainRate"><code class="xref py py-class docutils literal notranslate"><span class="pre">strain</span> <span class="pre">rate</span></code></a>
that is <em>constant</em> across the triangle (and is zero if the triangle is <em>not</em> <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle.is_in_deforming_region" title="pygplates.NetworkTriangulation.Triangle.is_in_deforming_region"><code class="xref py py-attr docutils literal notranslate"><span class="pre">deforming</span></code></a>).
Furthermore, the strain rate of each triangle can optionally be <a class="reference internal" href="#pygplates-primer-strain-rate-clamping"><span class="std std-ref">clamped to a maximum strain rate</span></a>.
Then each <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Vertex" title="pygplates.NetworkTriangulation.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">vertex</span></code></a> in the triangulation is assigned a strain rate that is an area-weighted average of the (potentially clamped) strain rates
from <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle.is_in_deforming_region" title="pygplates.NetworkTriangulation.Triangle.is_in_deforming_region"><code class="xref py py-attr docutils literal notranslate"><span class="pre">deforming</span></code></a> triangles incident to the vertex.</p>
<p>Finally, the strain rate that is queried at an <em>arbitrary</em> location (within the deforming triangulation) is either assigned the strain rate of the triangle containing that location,
or calculated by interpolating the strain rates of nearby vertices if <a class="reference internal" href="#pygplates-primer-strain-rate-smoothing"><span class="std std-ref">strain rates are smoothed</span></a>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Both strain rate <a class="reference internal" href="#pygplates-primer-strain-rate-clamping"><span class="std std-ref">clamping</span></a> and <a class="reference internal" href="#pygplates-primer-strain-rate-smoothing"><span class="std std-ref">smoothing</span></a> affect strain <em>rate</em> queries
(such as <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_strain_rates" title="pygplates.ReconstructedGeometryTimeSpan.get_strain_rates"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_strain_rates()</span></code></a>). They also affects <em>strain</em> queries (such as <a class="reference internal" href="generated/pygplates.ReconstructedGeometryTimeSpan.html#pygplates.ReconstructedGeometryTimeSpan.get_strains" title="pygplates.ReconstructedGeometryTimeSpan.get_strains"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ReconstructedGeometryTimeSpan.get_strains()</span></code></a>),
since strain is <a class="reference internal" href="generated/pygplates.Strain.html#pygplates.Strain.accumulate" title="pygplates.Strain.accumulate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">accumulated</span></code></a> from strain rate.</p>
</div>
<section id="strain-rate-clamping">
<span id="pygplates-primer-strain-rate-clamping"></span><h4><a class="toc-backref" href="#id75" role="doc-backlink">Strain rate clamping</a><a class="headerlink" href="#strain-rate-clamping" title="Link to this heading"></a></h4>
<p>Strain rates can optionally be clamped to a maximum strain rate to avoid excessive or spurious extension/compression in some triangles of a deforming triangulation.
This can happen in some topological networks depending on how they were built.</p>
<p>It is the <a class="reference internal" href="generated/pygplates.StrainRate.html#pygplates.StrainRate.get_total_strain_rate" title="pygplates.StrainRate.get_total_strain_rate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">total</span> <span class="pre">strain</span> <span class="pre">rate</span></code></a> that is clamped, since it includes both the normal and shear components of deformation.
When a strain rate is clamped, all components of its tensor (specifically its <a class="reference internal" href="generated/pygplates.StrainRate.html#pygplates.StrainRate.get_velocity_spatial_gradient" title="pygplates.StrainRate.get_velocity_spatial_gradient"><code class="xref py py-class docutils literal notranslate"><span class="pre">spatial</span> <span class="pre">gradients</span> <span class="pre">of</span> <span class="pre">velocity</span> <span class="pre">tensor</span></code></a>)
are scaled equally to ensure its total strain rate equals the maximum total strain rate.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Clamping the total strain rate also limits quantities derived from strain rate such as crustal thinning and tectonic subsidence.</p>
</div>
<p>Strain rate clamping is determined by <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters.enable_strain_rate_clamping" title="pygplates.ResolveTopologyParameters.enable_strain_rate_clamping"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters.enable_strain_rate_clamping</span></code></a> when topological networks are resolved at a reconstruction time
(using <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a>, <a class="reference internal" href="generated/pygplates.TopologicalSnapshot.html#pygplates.TopologicalSnapshot" title="pygplates.TopologicalSnapshot"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalSnapshot</span></code></a> or <a class="reference internal" href="generated/pygplates.resolve_topologies.html#pygplates.resolve_topologies" title="pygplates.resolve_topologies"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygplates.resolve_topologies()</span></code></a>).
And the maximum strain rate is <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters.max_clamped_strain_rate" title="pygplates.ResolveTopologyParameters.max_clamped_strain_rate"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters.max_clamped_strain_rate</span></code></a>.
For example, to enable strain rate clamping (which is disabled by default) for a topological model, but keep the default maximum strain rate:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topological_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalModel</span><span class="p">(</span>
   <span class="s1">&#39;topologies.gpml&#39;</span><span class="p">,</span>
   <span class="s1">&#39;rotations.rot&#39;</span><span class="p">,</span>
   <span class="n">default_resolve_topology_parameters</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolveTopologyParameters</span><span class="p">(</span>
      <span class="n">enable_strain_rate_clamping</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
</section>
<section id="strain-rate-smoothing">
<span id="pygplates-primer-strain-rate-smoothing"></span><h4><a class="toc-backref" href="#id76" role="doc-backlink">Strain rate smoothing</a><a class="headerlink" href="#strain-rate-smoothing" title="Link to this heading"></a></h4>
<p>Strain rates can optionally be smoothed to help reduce the faceted (piecewise constant) strain rate across a deforming triangulation (due to each triangle having a <em>constant</em> strain rate across its face).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Smoothing the strain rate also affects quantities derived from strain rate such as crustal thinning and tectonic subsidence.</p>
</div>
<p>The strain rate at an arbitrary location within a deforming triangulation is affected by the smoothing value:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">pygplates.StrainRateSmoothing.none</span></code> - No smoothing. The strain rate is equal to the (constant) strain rate of the <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle" title="pygplates.NetworkTriangulation.Triangle"><code class="xref py py-class docutils literal notranslate"><span class="pre">triangle</span></code></a> containing the query location.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pygplates.StrainRateSmoothing.barycentric</span></code> - Use linear interpolation of the strain rates of the 3 <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Vertex" title="pygplates.NetworkTriangulation.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">vertices</span></code></a> of the
<a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Triangle" title="pygplates.NetworkTriangulation.Triangle"><code class="xref py py-class docutils literal notranslate"><span class="pre">triangle</span></code></a> containing the query location.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">pygplates.StrainRateSmoothing.natural_neighbour</span></code> - Use natural neighbour interpolation of the strain rates of triangulation <a class="reference internal" href="generated/pygplates.NetworkTriangulation.html#pygplates.NetworkTriangulation.Vertex" title="pygplates.NetworkTriangulation.Vertex"><code class="xref py py-class docutils literal notranslate"><span class="pre">vertices</span></code></a> near the query location.</p></li>
</ul>
<p>Strain rate smoothing is determined by <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters.strain_rate_smoothing" title="pygplates.ResolveTopologyParameters.strain_rate_smoothing"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters.strain_rate_smoothing</span></code></a> when topological networks are resolved at a reconstruction time
(using <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a>, <a class="reference internal" href="generated/pygplates.TopologicalSnapshot.html#pygplates.TopologicalSnapshot" title="pygplates.TopologicalSnapshot"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalSnapshot</span></code></a> or <a class="reference internal" href="generated/pygplates.resolve_topologies.html#pygplates.resolve_topologies" title="pygplates.resolve_topologies"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygplates.resolve_topologies()</span></code></a>).
For example, to disable strain rate smoothing (which is natural neighbour smoothing by default) for a topological model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topological_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalModel</span><span class="p">(</span>
   <span class="s1">&#39;topologies.gpml&#39;</span><span class="p">,</span>
   <span class="s1">&#39;rotations.rot&#39;</span><span class="p">,</span>
   <span class="n">default_resolve_topology_parameters</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolveTopologyParameters</span><span class="p">(</span>
      <span class="n">strain_rate_smoothing</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">StrainRateSmoothing</span><span class="o">.</span><span class="n">none</span><span class="p">))</span>
</pre></div>
</div>
</section>
</section>
<section id="exponential-rift-stretching-profile">
<span id="pygplates-primer-exponential-rift-stretching-profile"></span><h3><a class="toc-backref" href="#id77" role="doc-backlink">Exponential rift stretching profile</a><a class="headerlink" href="#exponential-rift-stretching-profile" title="Link to this heading"></a></h3>
<p>A rift is typically modeled using two topological networks, one on each side of the rift axis. Each side of the rift axis typically has a single row of triangles (between the un-stretched side and the rift axis).
As a result, the strain rate at any location within the rift will essentially be <em>constant</em>, even when the <a class="reference internal" href="#pygplates-primer-strain-rate-smoothing"><span class="std std-ref">strain rates are smoothed</span></a>.
This is because triangulation vertices, along both the un-stretched boundary line and the rift axis, will effectively end up with the strain rate of the triangles (which is constant across each triangle).</p>
<p>To avoid the problem of <em>constant</em> stretching across the rift, an <em>exponential</em> rift stretching profile can be activated by adding rift left/right plate ID properties to a topological network feature.</p>
<p>Internally the exponential strain rate profile is implemented by automatically adding more points to the interior of a deforming triangulation and distributing the velocities
at these points such that the strain rate varies exponentially (along the stretching direction) from the un-stretched side of the rift towards the rift axis.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This works reasonably well for regular rifts (like AFR-SAM), but not as well for oblique rifts (like AUS-ANT).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The exponential rift stretching profile affects quantities derived from strain rate such as crustal thinning and tectonic subsidence.</p>
</div>
<section id="rift-left-right-plate-ids">
<h4><a class="toc-backref" href="#id78" role="doc-backlink">Rift left/right plate IDs</a><a class="headerlink" href="#rift-left-right-plate-ids" title="Link to this heading"></a></h4>
<p>An <em>exponential</em> rift stretching profile is activated by adding a <code class="docutils literal notranslate"><span class="pre">gpml:riftLeftPlate</span></code>/<code class="docutils literal notranslate"><span class="pre">gpml:riftRightPlate</span></code> pair of conjugate plate ID properties to a topological network <a class="reference internal" href="generated/pygplates.Feature.html#pygplates.Feature" title="pygplates.Feature"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.Feature</span></code></a>.
This can be done, for example, by using the <em>rift_parameters</em> argument of <a class="reference internal" href="generated/pygplates.Feature.html#pygplates.Feature.create_topological_network_feature" title="pygplates.Feature.create_topological_network_feature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.Feature.create_topological_network_feature()</span></code></a>.
The presence of these plate IDs triggers the internal generation of an exponential strain rate rift profile when the topological networks are resolved at a reconstruction time
(using <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a>, <a class="reference internal" href="generated/pygplates.TopologicalSnapshot.html#pygplates.TopologicalSnapshot" title="pygplates.TopologicalSnapshot"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalSnapshot</span></code></a> or <a class="reference internal" href="generated/pygplates.resolve_topologies.html#pygplates.resolve_topologies" title="pygplates.resolve_topologies"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygplates.resolve_topologies()</span></code></a>).</p>
<p>For example, to create a rift between Africa and South America:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SAM_rift_network</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalNetwork</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="n">SAM_rift_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="o">.</span><span class="n">create_topological_network_feature</span><span class="p">(</span>
    <span class="n">SAM_rift_network</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;SAM rift&#39;</span><span class="p">,</span>
    <span class="n">valid_time</span><span class="o">=</span><span class="p">(</span><span class="mi">145</span><span class="p">,</span> <span class="mi">115</span><span class="p">),</span>
    <span class="n">rift_parameters</span><span class="o">=</span><span class="p">(</span><span class="mi">201</span><span class="p">,</span> <span class="mi">701</span><span class="p">))</span>
<span class="n">SAM_rift_feature</span><span class="o">.</span><span class="n">set_reconstruction_plate_id</span><span class="p">(</span><span class="mi">201</span><span class="p">)</span>

<span class="n">AFR_rift_network</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">GpmlTopologicalNetwork</span><span class="p">([</span><span class="o">...</span><span class="p">])</span>
<span class="n">AFR_rift_feature</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">Feature</span><span class="o">.</span><span class="n">create_topological_network_feature</span><span class="p">(</span>
    <span class="n">AFR_rift_network</span><span class="p">,</span>
    <span class="n">name</span><span class="o">=</span><span class="s1">&#39;AFR rift&#39;</span><span class="p">,</span>
    <span class="n">valid_time</span><span class="o">=</span><span class="p">(</span><span class="mi">145</span><span class="p">,</span> <span class="mi">115</span><span class="p">),</span>
    <span class="n">rift_parameters</span><span class="o">=</span><span class="p">(</span><span class="mi">201</span><span class="p">,</span> <span class="mi">701</span><span class="p">))</span>
<span class="n">AFR_rift_feature</span><span class="o">.</span><span class="n">set_reconstruction_plate_id</span><span class="p">(</span><span class="mi">701</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the rift left/right plate ID properties are not present in a topological network feature then it is <em>not</em> considered a <em>rift</em>.</p>
</div>
<p>There are also three other parameters, in addition to the rift left/right plate IDs, that are optional and can either be set individually in each a topological network feature
(eg, using the <em>rift_parameters</em> argument of <a class="reference internal" href="generated/pygplates.Feature.html#pygplates.Feature.create_topological_network_feature" title="pygplates.Feature.create_topological_network_feature"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.Feature.create_topological_network_feature()</span></code></a>) or as default values for all topological network features
(using <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters" title="pygplates.ResolveTopologyParameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters</span></code></a>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If these parameters are set in both places, then the feature properties have precedence.</p>
</div>
<p>When set on a topological network feature they become feature properties named:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">gpml:riftExponentialStretchingConstant</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gpml:riftStrainRateResolutionLog10</span></code> (note that this is <span class="math notranslate nohighlight">\(\log_{10}\)</span> of the rift strain rate resolution)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gpml:riftEdgeLengthThresholdDegrees</span></code></p></li>
</ul>
<p>…and for features missing these properties these parameters are instead obtained from <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters" title="pygplates.ResolveTopologyParameters"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters</span></code></a> attributes:</p>
<ul class="simple">
<li><p><a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters.rift_exponential_stretching_constant" title="pygplates.ResolveTopologyParameters.rift_exponential_stretching_constant"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters.rift_exponential_stretching_constant</span></code></a></p></li>
<li><p><a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters.rift_strain_rate_resolution" title="pygplates.ResolveTopologyParameters.rift_strain_rate_resolution"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters.rift_strain_rate_resolution</span></code></a></p></li>
<li><p><a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters.rift_edge_length_threshold_degrees" title="pygplates.ResolveTopologyParameters.rift_edge_length_threshold_degrees"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters.rift_edge_length_threshold_degrees</span></code></a></p></li>
</ul>
<p>…when the topological networks are resolved at a reconstruction time
(using <a class="reference internal" href="generated/pygplates.TopologicalModel.html#pygplates.TopologicalModel" title="pygplates.TopologicalModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalModel</span></code></a>, <a class="reference internal" href="generated/pygplates.TopologicalSnapshot.html#pygplates.TopologicalSnapshot" title="pygplates.TopologicalSnapshot"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.TopologicalSnapshot</span></code></a> or <a class="reference internal" href="generated/pygplates.resolve_topologies.html#pygplates.resolve_topologies" title="pygplates.resolve_topologies"><code class="xref py py-func docutils literal notranslate"><span class="pre">pygplates.resolve_topologies()</span></code></a>).</p>
<p>The default values (in <a class="reference internal" href="generated/pygplates.ResolveTopologyParameters.html#pygplates.ResolveTopologyParameters.__init__" title="pygplates.ResolveTopologyParameters.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pygplates.ResolveTopologyParameters()</span></code></a>) should be fine
for resolving rift features that do not contain the associated rift feature properties. But you can change the defaults as needed.
For example, new default values can be specified for a topological model:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">topological_model</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">TopologicalModel</span><span class="p">(</span>
   <span class="s1">&#39;topologies.gpml&#39;</span><span class="p">,</span>
   <span class="s1">&#39;rotations.rot&#39;</span><span class="p">,</span>
   <span class="n">default_resolve_topology_parameters</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">ResolveTopologyParameters</span><span class="p">(</span>
      <span class="n">rift_exponential_stretching_constant</span> <span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span>  <span class="c1"># default is 1.0</span>
      <span class="n">rift_strain_rate_resolution</span> <span class="o">=</span> <span class="mf">1e-16</span><span class="p">,</span>         <span class="c1"># default is 5e-17</span>
      <span class="n">rift_edge_length_threshold_degrees</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">))</span>   <span class="c1"># default is 0.1</span>
</pre></div>
</div>
</section>
<section id="rift-exponential-stretching-constant">
<h4><a class="toc-backref" href="#id79" role="doc-backlink">Rift exponential stretching constant</a><a class="headerlink" href="#rift-exponential-stretching-constant" title="Link to this heading"></a></h4>
<p>The strain rate in the rift stretching direction varies exponentially from the un-stretched side of the rift towards the rift axis.
The spatial variation in strain rate is:</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[strain\_rate(x) = strain\_rate \times e^{C x} \frac{C}{e^C - 1}\]</div>
</div></blockquote>
<p>…where <span class="math notranslate nohighlight">\(strain\_rate\)</span> is the un-subdivided, original (constant) strain rate, <span class="math notranslate nohighlight">\(C\)</span> is the <em>rift exponential stretching constant</em>
and <span class="math notranslate nohighlight">\(x = 0\)</span> at the un-stretched side and <span class="math notranslate nohighlight">\(x = 1\)</span> at the stretched point. Therefore <span class="math notranslate nohighlight">\(strain\_rate(0) &lt; strain\_rate &lt; strain\_rate(1)\)</span>.
For example, when <span class="math notranslate nohighlight">\(C = 1.0\)</span> then <span class="math notranslate nohighlight">\(strain\_rate(0) = 0.58 \times strain\_rate\)</span> and <span class="math notranslate nohighlight">\(strain\_rate(1) = 1.58 \times strain\_rate\)</span>.</p>
</section>
<section id="rift-strain-rate-resolution">
<h4><a class="toc-backref" href="#id80" role="doc-backlink">Rift strain rate resolution</a><a class="headerlink" href="#rift-strain-rate-resolution" title="Link to this heading"></a></h4>
<p>The <em>rift strain rate resolution</em> controls how accurately the actual strain rate curve (across rift profile) matches the exponential curve (in units of <span class="math notranslate nohighlight">\(second^{-1}\)</span>).
Rift edges in the network triangulation are sub-divided until the strain rate matches the exponential curve (within this tolerance).</p>
</section>
<section id="rift-edge-length-threshold">
<h4><a class="toc-backref" href="#id81" role="doc-backlink">Rift edge length threshold</a><a class="headerlink" href="#rift-edge-length-threshold" title="Link to this heading"></a></h4>
<p>Rift edges in network triangulation shorter than the <em>rift edge length threshold</em> (in degrees) will not be further sub-divided.</p>
</section>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pygplates_getting_started.html" class="btn btn-neutral float-left" title="Getting started" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pygplates_sample_code.html" class="btn btn-neutral float-right" title="Sample code" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright (C) 2003-2024 The University of Sydney, Australia
(C) 2004-2024 California Institute of Technology
(C) 2007-2024 The Geological Survey of Norway
.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>