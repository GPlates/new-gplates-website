<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pygplates.PolylineOnSphere &mdash; pygplates 0.36.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pygplates.PolygonOnSphere" href="pygplates.PolygonOnSphere.html" />
    <link rel="prev" title="pygplates.MultiPointOnSphere" href="pygplates.MultiPointOnSphere.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> pygplates
          </a>
              <div class="version">
                0.36
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../pygplates_introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pygplates_getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pygplates_sample_code.html">Sample code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pygplates_foundations.html">Foundations</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../pygplates_reference.html">Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#reconstruction">Reconstruction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#topology">Topology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#velocity">Velocity</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#rotation">Rotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#plate-partitioning">Plate Partitioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#file-i-o">File I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#feature">Feature</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#feature-property">Feature property</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#feature-property-value">Feature property value</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../pygplates_reference.html#geometry">Geometry</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="pygplates.PointOnSphere.html">pygplates.PointOnSphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.MultiPointOnSphere.html">pygplates.MultiPointOnSphere</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">pygplates.PolylineOnSphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.PolygonOnSphere.html">pygplates.PolygonOnSphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.GeometryOnSphere.html">pygplates.GeometryOnSphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.GreatCircleArc.html">pygplates.GreatCircleArc</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.LatLonPoint.html">pygplates.LatLonPoint</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#vector">Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#string">String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#utility">Utility</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pygplates</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../pygplates_reference.html">Reference</a> &raquo;</li>
      <li>pygplates.PolylineOnSphere</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/generated/pygplates.PolylineOnSphere.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pygplates-polylineonsphere">
<h1>pygplates.PolylineOnSphere<a class="headerlink" href="#pygplates-polylineonsphere" title="Permalink to this headline"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygplates.</span></span><span class="sig-name descname"><span class="pre">PolylineOnSphere</span></span><a class="headerlink" href="#pygplates.PolylineOnSphere" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">pygplates.GeometryOnSphere</span></code></a></p>
<p>Represents a polyline on the surface of the unit length sphere. Polylines are equality (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>) comparable (but not hashable - cannot be used as a key in a <code class="docutils literal notranslate"><span class="pre">dict</span></code>). See <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> for an overview of equality in the presence of limited floating-point precision.</p>
<p>A polyline instance is both:</p>
<ul class="simple">
<li><p>a sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">points</span></code></a> - see <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere.get_points" title="pygplates.GeometryOnSphere.get_points"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_points</span></code></a>, and</p></li>
<li><p>a sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segments</span></code></a> (between adjacent points) - see <a class="reference internal" href="#pygplates.PolylineOnSphere.get_segments" title="pygplates.PolylineOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segments()</span></code></a>.</p></li>
</ul>
<p>In addition a polyline instance is <em>directly</em> iterable over its points (without having to use <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere.get_points" title="pygplates.GeometryOnSphere.get_points"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_points</span></code></a>):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">polyline</span><span class="p">:</span>
    <span class="o">...</span>
</pre></div>
</div>
<p>…and so the following operations for accessing the points are supported:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">len(polyline)</span></code></p></td>
<td><p>number of vertices in <em>polyline</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">p</span> <span class="pre">in</span> <span class="pre">polyline</span></code></p></td>
<td><p>iterates over the vertices <em>p</em> of <em>polyline</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">in</span> <span class="pre">polyline</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>p</em> is equal to a <strong>vertex</strong> of <em>polyline</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">p</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">polyline</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code> if <em>p</em> is equal to a <strong>vertex</strong> of <em>polyline</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">polyline[i]</span></code></p></td>
<td><p>the vertex of <em>polyline</em> at index <em>i</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">polyline[i:j]</span></code></p></td>
<td><p>slice of <em>polyline</em> from <em>i</em> to <em>j</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">polyline[i:j:k]</span></code></p></td>
<td><p>slice of <em>polyline</em> from <em>i</em> to <em>j</em> with step <em>k</em></p></td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line">Since a <em>PolylineOnSphere</em> is <strong>immutable</strong> it contains no operations or methods that modify its state (such as adding or removing points). This is similar to other immutable types in python such as <code class="docutils literal notranslate"><span class="pre">str</span></code>.</div>
<div class="line">So instead of modifying an existing polyline you will need to create a new <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> instance as the following example demonstrates:</div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get a list of points from an existing PolylineOnSphere &#39;polyline&#39;.</span>
<span class="n">points</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polyline</span><span class="p">)</span>

<span class="c1"># Modify the points list somehow.</span>
<span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>

<span class="c1"># &#39;polyline&#39; now references a new PolylineOnSphere instance.</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolylineOnSphere.__init__" title="Permalink to this definition"></a></dt>
<dd><p>A <em>PolylineOnSphere</em> object can be constructed in more than one way…</p>
<dl>
<dt>__init__(points)</dt><dd><p>Create a polyline from a sequence of (x,y,z) or (latitude,longitude) points.</p>
<dl class="field-list simple">
<dt class="field-odd">param points</dt>
<dd class="field-odd"><p>A sequence of (x,y,z) points, or (latitude,longitude) points (in degrees).</p>
</dd>
<dt class="field-even">type points</dt>
<dd class="field-even"><p>Any sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (float,float,float) or tuple (float,float)</p>
</dd>
<dt class="field-odd">raises</dt>
<dd class="field-odd"><p>InvalidLatLonError if any <em>latitude</em> or <em>longitude</em> is invalid</p>
</dd>
<dt class="field-even">raises</dt>
<dd class="field-even"><p>ViolatedUnitVectorInvariantError if any (x,y,z) is not unit magnitude</p>
</dd>
<dt class="field-odd">raises</dt>
<dd class="field-odd"><p>InvalidPointsForPolylineConstructionError if sequence has less than two points or if any two points (adjacent in the <em>points</em> sequence) are antipodal to each other (on opposite sides of the globe)</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The sequence must contain at least two points in order to be a valid polyline, otherwise <em>InvalidPointsForPolylineConstructionError</em> will be raised.</p>
</div>
<p>During creation, a <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> is created between each adjacent pair of points in <em>points</em> - see <a class="reference internal" href="#pygplates.PolylineOnSphere.get_segments" title="pygplates.PolylineOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segments()</span></code></a>.</p>
<p>It is <em>not</em> an error for adjacent points in the sequence to be coincident. In this case each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> between two such adjacent points will have zero length (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.is_zero_length" title="pygplates.GreatCircleArc.is_zero_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.is_zero_length()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">True</span></code>) and will have no rotation axis (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_rotation_axis" title="pygplates.GreatCircleArc.get_rotation_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.get_rotation_axis()</span></code></a> will raise an error). However if two such adjacent points are antipodal (on opposite sides of the globe) then InvalidPointsForPolylineConstructionError will be raised.</p>
<p>The following example shows a few different ways to create a <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">polyline</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat1</span><span class="p">,</span><span class="n">lon1</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat2</span><span class="p">,</span><span class="n">lon2</span><span class="p">))</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lat3</span><span class="p">,</span><span class="n">lon3</span><span class="p">))</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>

<span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">z1</span><span class="p">])</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x2</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">z2</span><span class="p">])</span>
<span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">x3</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">z3</span><span class="p">])</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have latitude/longitude values but they are not a sequence of tuples or if the latitude/longitude order is swapped then the following examples demonstrate how you could restructure them:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Flat lat/lon array.</span>
<span class="n">points</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lon1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat3</span><span class="p">,</span> <span class="n">lon3</span><span class="p">])</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># Flat lon/lat list (ie, different latitude/longitude order).</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">]</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span><span class="n">points</span><span class="p">[::</span><span class="mi">2</span><span class="p">]))</span>

<span class="c1"># Separate lat/lon arrays.</span>
<span class="n">lats</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lat1</span><span class="p">,</span> <span class="n">lat2</span><span class="p">,</span> <span class="n">lat3</span><span class="p">])</span>
<span class="n">lons</span> <span class="o">=</span> <span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lon2</span><span class="p">,</span> <span class="n">lon3</span><span class="p">])</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">lats</span><span class="p">,</span><span class="n">lons</span><span class="p">))</span>

<span class="c1"># Lon/lat list of tuples (ie, different latitude/longitude order).</span>
<span class="n">points</span> <span class="o">=</span> <span class="p">[(</span><span class="n">lon1</span><span class="p">,</span> <span class="n">lat1</span><span class="p">),</span> <span class="p">(</span><span class="n">lon2</span><span class="p">,</span> <span class="n">lat2</span><span class="p">),</span> <span class="p">(</span><span class="n">lon3</span><span class="p">,</span> <span class="n">lat3</span><span class="p">)]</span>
<span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">([(</span><span class="n">lat</span><span class="p">,</span><span class="n">lon</span><span class="p">)</span> <span class="k">for</span> <span class="n">lon</span><span class="p">,</span> <span class="n">lat</span> <span class="ow">in</span> <span class="n">points</span><span class="p">])</span>
</pre></div>
</div>
</dd>
<dt>__init__(geometry, [allow_one_point=True])</dt><dd><p>Create a polyline from a <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">param geometry</dt>
<dd class="field-odd"><p>The point, multi-point, polyline or polygon geometry to convert from.</p>
</dd>
<dt class="field-even">type geometry</dt>
<dd class="field-even"><p><a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a></p>
</dd>
<dt class="field-odd">param allow_one_point</dt>
<dd class="field-odd"><p>Whether <em>geometry</em> is allowed to be a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> containing only a single point - if allowed then that single point is duplicated since a PolylineOnSphere requires at least two points - default is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
</dd>
<dt class="field-even">type allow_one_point</dt>
<dd class="field-even"><p>bool</p>
</dd>
<dt class="field-odd">raises</dt>
<dd class="field-odd"><p>InvalidPointsForPolylineConstructionError if <em>geometry</em> is a <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> (and <em>allow_one_point</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code>), or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> with one point (and <em>allow_one_point</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code>), or if any two consecutive points in a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> are antipodal to each other (on opposite sides of the globe)</p>
</dd>
</dl>
<p>If <em>allow_one_point</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code> then <em>geometry</em> can be <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a>, <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a>, <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> or <a class="reference internal" href="pygplates.PolygonOnSphere.html#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a>. However if <em>allow_one_point</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> then <em>geometry</em> must be a <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a>, or a <a class="reference internal" href="pygplates.PolygonOnSphere.html#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a>, or a <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> containing at least two points to avoid raising <em>InvalidPointsForPolylineConstructionError</em>.</p>
<p>During creation, a <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> is created between each adjacent pair of geometry points - see <a class="reference internal" href="#pygplates.PolylineOnSphere.get_segments" title="pygplates.PolylineOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_segments()</span></code></a>.</p>
<p>It is <em>not</em> an error for adjacent points in a geometry sequence to be coincident. In this case each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> between two such adjacent points will have zero length (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.is_zero_length" title="pygplates.GreatCircleArc.is_zero_length"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.is_zero_length()</span></code></a> will return <code class="docutils literal notranslate"><span class="pre">True</span></code>) and will have no rotation axis (<a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.get_rotation_axis" title="pygplates.GreatCircleArc.get_rotation_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.get_rotation_axis()</span></code></a> will raise an error). However if two such adjacent points are antipodal (on opposite sides of the globe) then InvalidPointsForPolylineConstructionError will be raised</p>
<p>To create a PolylineOnSphere from any geometry type:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
<p>To create a PolylineOnSphere from any geometry containing at least two points:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">try</span><span class="p">:</span>
    <span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">allow_one_point</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="k">except</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">InvalidPointsForPolylineConstructionError</span><span class="p">:</span>
    <span class="o">...</span> <span class="c1"># Handle failure to convert &#39;geometry&#39; to a PolylineOnSphere.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <em>geometry</em> is a polygon then only its exterior ring is converted (interior rings are ignored).</p>
</div>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.PolylineOnSphere.__init__" title="pygplates.PolylineOnSphere.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(...)</p></td>
<td><p>A <em>PolylineOnSphere</em> object can be constructed in more than one way...</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">clone</span></code>()</p></td>
<td><p>Create a duplicate of this geometry (derived) instance.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code>(geometry1, geometry2, ...)</p></td>
<td><p>[<em>staticmethod</em>] Returns the (minimum) distance between two geometries (in radians).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.PolylineOnSphere.get_arc_length" title="pygplates.PolylineOnSphere.get_arc_length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_arc_length</span></code></a>()</p></td>
<td><p>Returns the total arc length of this polyline (in radians).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.PolylineOnSphere.get_centroid" title="pygplates.PolylineOnSphere.get_centroid"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_centroid</span></code></a>()</p></td>
<td><p>Returns the centroid of this polyline.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_points</span></code>()</p></td>
<td><p>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">points</span></code></a> in this geometry.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.PolylineOnSphere.get_segments" title="pygplates.PolylineOnSphere.get_segments"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_segments</span></code></a>()</p></td>
<td><p>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segments</span></code></a> in this polyline.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.PolylineOnSphere.join" title="pygplates.PolylineOnSphere.join"><code class="xref py py-obj docutils literal notranslate"><span class="pre">join</span></code></a>(geometries, ...)</p></td>
<td><p>Joins geometries that have end points closer than a distance threshold.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.PolylineOnSphere.rotation_interpolate" title="pygplates.PolylineOnSphere.rotation_interpolate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotation_interpolate</span></code></a>(from_polyline, ...)</p></td>
<td><p>[<em>staticmethod</em>] Interpolates between two polylines about a rotation pole.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_lat_lon_array</span></code>()</p></td>
<td><p>Returns the sequence of points, in this geometry, as a numpy array of (latitude,longitude) pairs (in degrees).</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_lat_lon_list</span></code>()</p></td>
<td><p>Returns the sequence of points, in this geometry, as (latitude,longitude) tuples (in degrees).</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_lat_lon_point_list</span></code>()</p></td>
<td><p>Returns the sequence of points, in this geometry, as <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">lat</span> <span class="pre">lon</span> <span class="pre">points</span></code></a>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.PolylineOnSphere.to_tessellated" title="pygplates.PolylineOnSphere.to_tessellated"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_tessellated</span></code></a>(tessellate_radians)</p></td>
<td><p>Returns a new polyline that is tessellated version of this polyline.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_xyz_array</span></code>()</p></td>
<td><p>Returns the sequence of points, in this geometry, as a numpy array of (x,y,z) triplets.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">to_xyz_list</span></code>()</p></td>
<td><p>Returns the sequence of points, in this geometry, as (x,y,z) cartesian coordinate tuples.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere.get_arc_length">
<span class="sig-name descname"><span class="pre">get_arc_length</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolylineOnSphere.get_arc_length" title="Permalink to this definition"></a></dt>
<dd><p>Returns the total arc length of this polyline (in radians).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<div class="line-block">
<div class="line">This is the sum of the arc lengths of the <a class="reference internal" href="#pygplates.PolylineOnSphere.get_segments" title="pygplates.PolylineOnSphere.get_segments"><code class="xref py py-meth docutils literal notranslate"><span class="pre">segments</span></code></a> of this polyline.</div>
<div class="line">To convert to distance, multiply the result by the Earth radius (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><code class="xref py py-class docutils literal notranslate"><span class="pre">Earth</span></code></a>).</div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere.get_centroid">
<span class="sig-name descname"><span class="pre">get_centroid</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolylineOnSphere.get_centroid" title="Permalink to this definition"></a></dt>
<dd><p>Returns the centroid of this polyline.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a></p>
</dd>
</dl>
<p>The centroid is calculated as a weighted average of the mid-points of the <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">great</span> <span class="pre">circle</span> <span class="pre">arcs</span></code></a> of this polyline with weighting proportional to the individual arc lengths.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere.get_segments">
<span class="sig-name descname"><span class="pre">get_segments</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolylineOnSphere.get_segments" title="Permalink to this definition"></a></dt>
<dd><p>Returns a <em>read-only</em> sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segments</span></code></a> in this polyline.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>a read-only sequence of <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a></p>
</dd>
</dl>
<p>The following operations for accessing the great circle arcs in the returned read-only sequence are supported:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 30%" />
<col style="width: 70%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">len(seq)</span></code></p></td>
<td><p>number of segments of the polyline</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">s</span> <span class="pre">in</span> <span class="pre">seq</span></code></p></td>
<td><p>iterates over the segments <em>s</em> of the polyline</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">in</span> <span class="pre">seq</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">True</span></code> if <em>s</em> is an segment of the polyline</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">s</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">seq</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">False</span></code> if <em>s</em> is an segment of the polyline</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">seq[i]</span></code></p></td>
<td><p>the segment of the polyline at index <em>i</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">seq[i:j]</span></code></p></td>
<td><p>slice of segments of the polyline from <em>i</em> to <em>j</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">seq[i:j:k]</span></code></p></td>
<td><p>slice of segments of the polyline from <em>i</em> to <em>j</em> with step <em>k</em></p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Between each adjacent pair of <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">points</span></code></a> there is an <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segment</span></code></a> such that the number of points exceeds the number of segments by one.</p>
</div>
<p>The following example demonstrates some uses of the above operations:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
<span class="o">...</span>
<span class="n">segments</span> <span class="o">=</span> <span class="n">polyline</span><span class="o">.</span><span class="n">get_segments</span><span class="p">()</span>
<span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">:</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">segment</span><span class="o">.</span><span class="n">is_zero_length</span><span class="p">():</span>
        <span class="n">segment_midpoint_direction</span> <span class="o">=</span> <span class="n">segment</span><span class="o">.</span><span class="n">get_arc_direction</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">first_segment</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">last_segment</span> <span class="o">=</span> <span class="n">segments</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned sequence is <em>read-only</em> and cannot be modified.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If you want a modifiable sequence consider wrapping the returned sequence in a <code class="docutils literal notranslate"><span class="pre">list</span></code> using something like <code class="docutils literal notranslate"><span class="pre">segments</span> <span class="pre">=</span> <span class="pre">list(polyline.get_segments())</span></code> <strong>but</strong> note that modifying the <code class="docutils literal notranslate"><span class="pre">list</span></code> (eg, appending a new segment) will <strong>not</strong> modify the original polyline.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere.join">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">join</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometries</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">distance_threshold_radians</span></span></em><span class="optional">]</span><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">polyline_conversion=PolylineConversion.ignore_non_polyline</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolylineOnSphere.join" title="Permalink to this definition"></a></dt>
<dd><p>Joins geometries that have end points closer than a distance threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geometries</strong> (sequence (eg, <code class="docutils literal notranslate"><span class="pre">list</span></code> or <code class="docutils literal notranslate"><span class="pre">tuple</span></code>) of <a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>) – the geometries to join</p></li>
<li><p><strong>distance_threshold_radians</strong> (<em>float</em>) – optional closeness distance threshold in radians for joining to occur     (if not specified then end point <em>equality</em> is used)</p></li>
<li><p><strong>polyline_conversion</strong> (<em>PolylineConversion.convert_to_polyline</em>, <em>PolylineConversion.ignore_non_polyline</em>     or <em>PolylineConversion.raise_if_non_polyline</em>) – whether to raise error, convert to <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> or ignore     those geometries in <em>geometries</em> that are not <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> - defaults to     <em>PolylineConversion.ignore_non_polyline</em></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>a list of joined polylines</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a></p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>GeometryTypeError if <em>polyline_conversion</em> is <em>PolylineConversion.raise_if_non_polyline</em> and     any geometry in <em>geometries</em> is not a <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a></p>
</dd>
</dl>
<p>All pairs of geometries are tested for joining and only those with end points closer than <em>distance_threshold_radians</em>
radians are joined. Each joined polyline is further joined if possible until there are no more
possibilities for joining (or there is a single joined polyline that is a concatenation of all
geometries in <em>geometries</em> - depending on <em>polyline_conversion</em>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If <em>distance_threshold_radians</em> is not specified then the end points must be equal
(rather than separated by less than a threshold distance).</p>
</div>
<p>When determining if two geometries A and B can be joined the closest pair of end points
(one from A and one from B) decides which end of each geometry can be joined, provided their
distance is less than <em>distance_threshold_radians</em> radians. If a third geometry C also has an
end point close enough to A then the closest of B and C is joined to A.</p>
<p>Two geometries A and B are joined by prepending or appending a (possibly reversed) copy of the
points in geometry B to a copy of the points in geometry A. Hence the joined polyline will
always have points ordered in the same direction as geometry A (only the points from geometry B are
reversed if necessary). So geometries earlier in the <em>geometries</em> sequence determine the direction
of joined polylines.</p>
<p>Join three polylines if their end points are within 3 degrees of another:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># If all three polylines join then the returned list will have one joined polyline.</span>
<span class="c1"># If only two polylines join then the returned list will have two polylines (one original and one joined).</span>
<span class="c1"># If no polylines join then the returned list will have the three original polylines.</span>
<span class="n">joined_polylines</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">polyline1</span><span class="p">,</span> <span class="n">polyline2</span><span class="p">,</span> <span class="n">polyline3</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>Other geometries besides <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> can be joined if <em>polyline_conversion</em> is
<em>PolylineConversion.convert_to_polyline</em>. This is useful for joining nearby points into polylines for example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># If all points are close enough then the returned list will have one joined polyline,</span>
<span class="c1"># otherwise there will be multiple polylines each representing a subset of the points.</span>
<span class="c1"># If none of the points are close to each other then the returned list will have degenerate</span>
<span class="c1"># polylines that each look like a point (each polyline has two identical points).</span>
<span class="n">joined_polylines</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
        <span class="n">points</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineConversion</span><span class="o">.</span><span class="n">convert_to_polyline</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere.rotation_interpolate">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rotation_interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_polyline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_polyline</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rotation_pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interpolate</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">minimum_latitude_overlap_radians=0</span></span></em><span class="optional">]</span><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">maximum_latitude_non_overlap_radians=0</span></span></em><span class="optional">]</span><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">maximum_distance_threshold_radians</span></span></em><span class="optional">]</span><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">flatten_longitude_overlaps=FlattenLongitudeOverlaps.no</span></span></em><span class="optional">]</span><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">polyline_conversion=PolylineConversion.ignore_non_polyline</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolylineOnSphere.rotation_interpolate" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Interpolates between two polylines about a rotation pole.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_polyline</strong> (<a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>) – the polyline to interpolate <em>from</em></p></li>
<li><p><strong>to_polyline</strong> (<a class="reference internal" href="pygplates.GeometryOnSphere.html#pygplates.GeometryOnSphere" title="pygplates.GeometryOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeometryOnSphere</span></code></a>) – the polyline to interpolate <em>to</em></p></li>
<li><p><strong>rotation_pole</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the rotation axis to interpolate around</p></li>
<li><p><strong>interpolate</strong> (<em>float</em><em>, or </em><em>list of float</em>) – if a single number then <em>interpolate</em> is the interval spacing, in radians, between <em>from_polyline</em> and <em>to_polyline</em> at which to generate interpolated polylines - otherwise if a sequence of numbers (eg, list or tuple) then <em>interpolate</em> is the sequence of interpolate ratios, in the range [0,1], at which to generate interpolated polylines (with 0 meaning <em>from_polyline</em> and 1 meaning <em>to_polyline</em>)</p></li>
<li><p><strong>minimum_latitude_overlap_radians</strong> (<em>float - defaults to zero</em>) – required amount of latitude overlap of polylines</p></li>
<li><p><strong>maximum_latitude_non_overlap_radians</strong> (<em>float - defaults to zero</em>) – allowed non-overlapping latitude region</p></li>
<li><p><strong>maximum_distance_threshold_radians</strong> (<em>float - default is no threshold detection</em>) – maximum distance (in radians) between <em>from_polyline</em> and <em>to_polyline</em> - if specified and if exceeded then <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned</p></li>
<li><p><strong>flatten_longitude_overlaps</strong> (<em>FlattenLongitudeOverlaps.no</em>, <em>FlattenLongitudeOverlaps.use_from</em> or <em>FlattenLongitudeOverlaps.use_to</em> - defaults to <em>FlattenLongitudeOverlaps.no</em>) – whether or not to ensure <em>from_polyline</em> and <em>to_polyline</em> do not overlap in longitude (in North pole reference frame of <em>rotation_pole</em>) and how to correct the overlap</p></li>
<li><p><strong>polyline_conversion</strong> (<em>PolylineConversion.convert_to_polyline</em>, <em>PolylineConversion.ignore_non_polyline</em> or <em>PolylineConversion.raise_if_non_polyline</em>) – whether to raise error, convert to <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> or ignore <em>from_polyline</em> and <em>to_polyline</em> if they are not <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> (ignoring equates to returning <code class="docutils literal notranslate"><span class="pre">None</span></code>) - defaults to <em>PolylineConversion.ignore_non_polyline</em></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>list of interpolated polylines - or <code class="docutils literal notranslate"><span class="pre">None</span></code> if polylines do not have overlapping latitude ranges or if maximum distance threshold exceeded or if either polyline is not a <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> (and <em>polyline_conversion</em> is <em>PolylineConversion.ignore_non_polyline</em>)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>list of <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> or None</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>GeometryTypeError if <em>from_polyline</em> or <em>to_polyline</em> are not of type <a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> (and <em>polyline_conversion</em> is <em>PolylineConversion.raise_if_non_polyline</em>)</p>
</dd>
</dl>
<p>If <em>interpolate</em> is a single number then it is the distance interval spacing, in radians, between <em>from_polyline</em> and <em>to_polyline</em> at which to generate interpolated polylines. Also modified versions of <em>from_polyline</em> and <em>to_polyline</em> are returned along with the interpolated polylines.</p>
<p>If <em>interpolate</em> is a sequence of numbers (eg, list or tuple) then it is the sequence of interpolate ratios, in the range [0,1], at which to generate interpolated polylines (with 0 meaning <em>from_polyline</em> and 1 meaning <em>to_polyline</em> and values between meaning interpolated polylines).</p>
<p>The points in the returned polylines are ordered from closest (latitude) to <em>rotation_pole</em> to furthest (which may be different than the order in the original polylines). The modified versions of polylines <em>from_polyline</em> and <em>to_polyline</em>, and hence all interpolated polylines, have monotonically decreasing latitudes (in North pole reference frame of <em>rotation_pole</em>) starting with the northmost polyline end-point and (monotonically) decreasing southward such that subsequent points have latitudes lower than, or equal to, all previous points as shown in the following diagram:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>  <span class="o">/|</span>
 <span class="o">/</span> <span class="o">|</span>
<span class="o">/</span>  <span class="o">|</span>                       <span class="n">___</span>
   <span class="o">|</span>                          <span class="o">|</span>
   <span class="o">|</span> <span class="o">/|</span>                       <span class="o">|</span>
   <span class="o">|/</span> <span class="o">|</span>                       <span class="o">|</span><span class="n">__</span>
      <span class="o">|</span>                          <span class="o">|</span>
      <span class="o">|</span>           <span class="o">===&gt;</span>           <span class="o">|</span>
      <span class="o">|</span> <span class="o">/|</span>                       <span class="o">|</span>
      <span class="o">|/</span> <span class="o">|</span>                       <span class="o">|</span><span class="n">__</span>
         <span class="o">|</span>                          <span class="o">|</span>
          \                          \
           \                          \
            <span class="o">|</span>                          <span class="o">|</span>
            <span class="o">|</span> <span class="o">/</span>                        <span class="o">|</span>
            <span class="o">|/</span>                         <span class="o">|</span><span class="n">__</span>
</pre></div>
</div>
<p>The modified versions of polylines <em>from_polyline</em> and <em>to_polyline</em> are also clipped to have a common overlapping latitude range (with a certain amount of non-overlapping allowed if <em>max_latitude_non_overlap_radians</em> is non-zero).</p>
<p><em>minimum_latitude_overlap_radians</em> specifies the amount that <em>from_polyline</em> and <em>to_polyline</em> must overlap in latitude (North pole reference frame of <em>rotation_pole</em>), otherwise <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned. Note that this also means if the range of latitudes of either polyline is smaller than the minimum overlap then <code class="docutils literal notranslate"><span class="pre">None</span></code> is returned. The following diagram shows the original latitude overlapping polylines on the left and the resultant interpolated polylines on the right clipped to the latitude overlapping range (in <em>rotation_pole</em> reference frame):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span><span class="n">_</span>
  <span class="o">|</span>
  <span class="o">|</span>         <span class="o">|</span>                         <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>
  <span class="o">|</span><span class="n">_</span>        <span class="o">|</span><span class="n">_</span>          <span class="o">===&gt;</span>          <span class="o">|</span><span class="n">_</span>   <span class="o">|</span><span class="n">_</span>   <span class="o">|</span><span class="n">_</span>
    <span class="o">|</span>         <span class="o">|</span>                         <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>
    <span class="o">|</span>         <span class="o">|</span>                         <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>
              <span class="o">|</span><span class="n">_</span>
                <span class="o">|</span>
</pre></div>
</div>
<p>However problems can arise if <em>rotation_pole</em> is placed such that one, or both, the original polylines (<em>from_polyline</em> and <em>to_polyline</em>) strongly overlaps itself (in <em>rotation_pole</em> reference frame) causing the monotonically-decreasing-latitude requirement to severely distort its geometry. The following diagram shows the original polylines in the top of the diagram and the resultant interpolated polylines in the bottom of the diagram:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>                             \
                              \
         <span class="n">______</span>                \
    <span class="n">____</span><span class="o">|</span>      <span class="o">|</span><span class="n">____</span>            \
 <span class="n">__</span><span class="o">|</span>                <span class="o">|</span><span class="n">__</span>          \
<span class="o">/</span>                      \          \
                        \          \
                         <span class="o">|</span>          <span class="o">|</span>
                         <span class="o">|</span>          <span class="o">|</span>
                         <span class="o">|</span>          <span class="o">|</span>

             <span class="o">||</span>
             <span class="o">||</span>
             \<span class="o">/</span>

<span class="n">______________________________</span>
                        \     \    \
                         <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span>
                         <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span>
                         <span class="o">|</span>     <span class="o">|</span>    <span class="o">|</span>
</pre></div>
</div>
<p>If <em>maximum_latitude_non_overlap_radians</em> is non-zero then an extra range of non-overlapping latitudes at the North and South (in <em>rotation_pole</em> reference frame) of <em>from_polyline</em> and <em>to_polyline</em> is allowed. The following diagram shows the original latitude overlapping polylines on the left and the resultant interpolated polylines on the right with a limited amount of non-overlapping interpolation from the North end of one polyline and from the South end of the other (in <em>rotation_pole</em> reference frame):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">|</span>
<span class="o">|</span>
<span class="o">|</span>                                   <span class="o">|</span>
<span class="o">|</span>                                   <span class="o">|</span>    <span class="o">|</span>
<span class="o">|</span>         <span class="o">|</span>                         <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>
<span class="o">|</span><span class="n">_</span>        <span class="o">|</span><span class="n">_</span>          <span class="o">===&gt;</span>          <span class="o">|</span><span class="n">_</span>   <span class="o">|</span><span class="n">_</span>   <span class="o">|</span><span class="n">_</span>
  <span class="o">|</span>         <span class="o">|</span>                         <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>
  <span class="o">|</span>         <span class="o">|</span>                         <span class="o">|</span>    <span class="o">|</span>    <span class="o">|</span>
            <span class="o">|</span>                              <span class="o">|</span>    <span class="o">|</span>
            <span class="o">|</span>                                   <span class="o">|</span>
            <span class="o">|</span>
            <span class="o">|</span>
</pre></div>
</div>
<p>If <em>flatten_longitude_overlaps</em> is <em>FlattenLongitudeOverlaps.use_from</em> or <em>FlattenLongitudeOverlaps.use_to</em> then this function ensures the longitudes of each point pair of <em>from_polyline</em> and <em>to_polyline</em> (in North pole reference frame of <em>rotation_pole</em>) at the same latitude don’t overlap. For those point pairs where overlap occurs, the points in <em>from_polyline</em> are copied to the corresponding (same latitude) points in <em>to_polyline</em> if <em>FlattenLongitudeOverlaps.use_from</em> is used (and vice versa if <em>FlattenLongitudeOverlaps.use_to</em> is used). This essentially removes or flattens overlaps in longitude. The following diagram shows the original longitude overlapping polylines on the left and the resultant interpolated polylines on the right (in <em>rotation_pole</em> reference frame) after longitude flattening with <em>FlattenLongitudeOverlaps.use_from</em>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span>     <span class="nn">to</span>
  \     <span class="o">/</span>                             \  <span class="o">|</span>  <span class="o">/</span>
   \   <span class="o">/</span>                               \ <span class="o">|</span> <span class="o">/</span>
    \ <span class="o">/</span>                                 \<span class="o">|/</span>
     <span class="o">.</span>                                   <span class="o">.</span>
    <span class="o">/</span> \                                   \
   <span class="o">/</span>   \                                   \
  <span class="o">/</span>     \                                   \
 <span class="o">|</span>       <span class="o">|</span>                                   <span class="o">|</span>
 <span class="o">|</span>       <span class="o">|</span>           <span class="o">===&gt;</span>                    <span class="o">|</span>
 <span class="o">|</span>       <span class="o">|</span>                                   <span class="o">|</span>
  \     <span class="o">/</span>                                   <span class="o">/</span>
   \   <span class="o">/</span>                                   <span class="o">/</span>
    \ <span class="o">/</span>                                   <span class="o">/</span>
     <span class="o">.</span>                                   <span class="o">.</span>
    <span class="o">/</span> \                                 <span class="o">/|</span>\
   <span class="o">/</span>   \                               <span class="o">/</span> <span class="o">|</span> \
  <span class="o">/</span>     \                             <span class="o">/</span>  <span class="o">|</span>  \
 <span class="o">/</span>       \                           <span class="o">/</span>   <span class="o">|</span>   \
</pre></div>
</div>
<p>Returns <code class="docutils literal notranslate"><span class="pre">None</span></code> if:</p>
<ul class="simple">
<li><p>the polylines do not overlap by at least <em>minimum_latitude_overlap_radians</em> radians (where North pole is <em>rotation_axis</em>), or</p></li>
<li><p>any corresponding pair of points (same latitude) of the polylines are separated by a distance of more than <em>max_distance_threshold_radians</em> (if specified).</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All returned polylines have the same number of points.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Corresponding points in returned polylines (points at same indices) have the same latitude (in North pole reference frame of <em>rotation_pole</em>) except those points in the non-overlapping latitude ranges (if <em>maximum_latitude_non_overlap_radians</em> is specified).</p>
</div>
<p>To interpolate polylines with a spacing of 2 minutes (with a minimum required latitude overlap of 1 degree and with an allowed latitude non-overlap of up to 3 degrees and with no distance threshold and with no longitude overlaps flattened):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interpolated_polylines</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="o">.</span><span class="n">rotation_interpolate</span><span class="p">(</span>
    <span class="n">from_polyline</span><span class="p">,</span> <span class="n">to_polyline</span><span class="p">,</span> <span class="n">rotation_pole</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="mi">60</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>To interpolate polylines at interpolate ratios between 0 and 1 at 0.1 intervals (with a minimum required latitude overlap of 1 degree and with an allowed latitude non-overlap of up to 3 degrees and with no distance threshold and with no longitude overlaps flattened):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interpolated_polylines</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="o">.</span><span class="n">rotation_interpolate</span><span class="p">(</span>
    <span class="n">from_polyline</span><span class="p">,</span> <span class="n">to_polyline</span><span class="p">,</span> <span class="n">rotation_pole</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>
</pre></div>
</div>
<p>An easy way to test whether two polylines can possibly be interpolated without actually interpolating anything is to specify an empty list of interpolate ratios:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="o">.</span><span class="n">rotation_interpolate</span><span class="p">(</span>
        <span class="n">from_polyline</span><span class="p">,</span> <span class="n">to_polyline</span><span class="p">,</span> <span class="n">rotation_pole</span><span class="p">,</span> <span class="p">[],</span> <span class="o">...</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="c1"># &#39;from_polyline&#39; and &#39;to_polyline&#39; can be interpolated (ie, they overlap</span>
    <span class="c1"># and don&#39;t exceed the maximum distance threshold)</span>
    <span class="o">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.PolylineOnSphere.to_tessellated">
<span class="sig-name descname"><span class="pre">to_tessellated</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tessellate_radians</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.PolylineOnSphere.to_tessellated" title="Permalink to this definition"></a></dt>
<dd><p>Returns a new polyline that is tessellated version of this polyline.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>tessellate_radians</strong> (<em>float</em>) – maximum tessellation angle (in radians)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a></p>
</dd>
</dl>
<p>Adjacent points (in the returned tessellated polyline) are separated by no more than <em>tessellate_radians</em> on the globe.</p>
<p>Create a polyline tessellated to 2 degrees:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">tessellated_polyline</span> <span class="o">=</span> <span class="n">polyline</span><span class="o">.</span><span class="n">to_tessellated</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Since a <em>PolylineOnSphere</em> is immutable it cannot be modified. Which is why a new (tessellated) <em>PolylineOnSphere</em> is returned.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The distance between adjacent points (in the tessellated polyline) will not be exactly <em>uniform</em>. This is because each <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">segment</span></code></a> in the original polyline is tessellated to the nearest integer number of points (that keeps that segment under the threshold) and hence each original <em>segment</em> will have a slightly different tessellation angle.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc.to_tessellated" title="pygplates.GreatCircleArc.to_tessellated"><code class="xref py py-meth docutils literal notranslate"><span class="pre">GreatCircleArc.to_tessellated()</span></code></a></p>
</div>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pygplates.MultiPointOnSphere.html" class="btn btn-neutral float-left" title="pygplates.MultiPointOnSphere" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pygplates.PolygonOnSphere.html" class="btn btn-neutral float-right" title="pygplates.PolygonOnSphere" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright (C) 2003-2022 The University of Sydney, Australia
(C) 2004-2022 California Institute of Technology
(C) 2007-2022 The Geological Survey of Norway
.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>