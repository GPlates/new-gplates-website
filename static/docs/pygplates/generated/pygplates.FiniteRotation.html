<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>pygplates.FiniteRotation &mdash; pygplates 0.36.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="pygplates.ReconstructionTree" href="pygplates.ReconstructionTree.html" />
    <link rel="prev" title="pygplates.RotationModel" href="pygplates.RotationModel.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> pygplates
          </a>
              <div class="version">
                0.36
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../pygplates_introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pygplates_getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pygplates_sample_code.html">Sample code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../pygplates_foundations.html">Foundations</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../pygplates_reference.html">Reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#reconstruction">Reconstruction</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#topology">Topology</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#velocity">Velocity</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../pygplates_reference.html#rotation">Rotation</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="pygplates.RotationModel.html">pygplates.RotationModel</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">pygplates.FiniteRotation</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.ReconstructionTree.html">pygplates.ReconstructionTree</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.ReconstructionTreeEdge.html">pygplates.ReconstructionTreeEdge</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.find_crossovers.html">pygplates.find_crossovers</a></li>
<li class="toctree-l3"><a class="reference internal" href="pygplates.synchronise_crossovers.html">pygplates.synchronise_crossovers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#plate-partitioning">Plate Partitioning</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#file-i-o">File I/O</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#feature">Feature</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#feature-property">Feature property</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#feature-property-value">Feature property value</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#geometry">Geometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#vector">Vector</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#string">String</a></li>
<li class="toctree-l2"><a class="reference internal" href="../pygplates_reference.html#utility">Utility</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">pygplates</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../pygplates_reference.html">Reference</a> &raquo;</li>
      <li>pygplates.FiniteRotation</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/generated/pygplates.FiniteRotation.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="pygplates-finiterotation">
<h1>pygplates.FiniteRotation<a class="headerlink" href="#pygplates-finiterotation" title="Permalink to this headline"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="pygplates.FiniteRotation">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pygplates.</span></span><span class="sig-name descname"><span class="pre">FiniteRotation</span></span><a class="headerlink" href="#pygplates.FiniteRotation" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Boost.Python.instance</span></code></p>
<p>Represents the motion of plates on the surface of the globe.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For general information on composing finite rotations in various plate tectonic scenarios see <a class="reference internal" href="../pygplates_foundations.html#pygplates-foundations-working-with-finite-rotations"><span class="std std-ref">Working with finite rotations</span></a>.</p>
</div>
<p>A finite rotation is a rotation about an <em>Euler pole</em> by an angular distance. An Euler pole is represented by a point on the surface of the globe where a rotation vector (radially extending from the centre of the globe) intersects the surface of the (unit radius) globe.</p>
<p>An Euler pole is specified by a point on the surface of the globe.</p>
<p>A rotation angle is specified in radians, with the usual sense of rotation:</p>
<ul class="simple">
<li><p>a positive angle represents an anti-clockwise rotation around the rotation vector,</p></li>
<li><p>a negative angle corresponds to a clockwise rotation.</p></li>
</ul>
<p>A finite rotation can be <a class="reference internal" href="#pygplates.FiniteRotation.__init__" title="pygplates.FiniteRotation.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">created</span></code></a>:</p>
<ul class="simple">
<li><p>explicitly from an Euler pole and an angle, or</p></li>
<li><p>from two points (rotates one point to the other along great circle arc), or</p></li>
<li><p>as an <a class="reference internal" href="#pygplates.FiniteRotation.create_identity_rotation" title="pygplates.FiniteRotation.create_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">identity</span></code></a> rotation (no rotation).</p></li>
</ul>
<p>The Euler pole and angle can be retrieved using:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#pygplates.FiniteRotation.get_euler_pole_and_angle" title="pygplates.FiniteRotation.get_euler_pole_and_angle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_euler_pole_and_angle()</span></code></a> as a tuple of Euler pole and angle (radians), or</p></li>
<li><p><a class="reference internal" href="#pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees" title="pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_lat_lon_euler_pole_and_angle_degrees()</span></code></a> as a tuple of Euler pole latitude and longitude and angle (all in degrees).</p></li>
</ul>
<p>Multiplication operations can be used to rotate various geometry types:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 26%" />
<col style="width: 74%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Result</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fr</span> <span class="pre">*</span> <span class="pre">vector</span></code></p></td>
<td><p>Rotates <a class="reference internal" href="pygplates.Vector3D.html#pygplates.Vector3D" title="pygplates.Vector3D"><code class="xref py py-class docutils literal notranslate"><span class="pre">Vector3D</span></code></a> <em>vector</em> using finite rotation <em>fr</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">fr</span> <span class="pre">*</span> <span class="pre">point</span></code></p></td>
<td><p>Rotates <a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> <em>point</em> using finite rotation <em>fr</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fr</span> <span class="pre">*</span> <span class="pre">multi_point</span></code></p></td>
<td><p>Rotates <a class="reference internal" href="pygplates.MultiPointOnSphere.html#pygplates.MultiPointOnSphere" title="pygplates.MultiPointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiPointOnSphere</span></code></a> <em>multi_point</em> using finite rotation <em>fr</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">fr</span> <span class="pre">*</span> <span class="pre">polyline</span></code></p></td>
<td><p>Rotates <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a> <em>polyline</em> using finite rotation <em>fr</em></p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">fr</span> <span class="pre">*</span> <span class="pre">polygon</span></code></p></td>
<td><p>Rotates <a class="reference internal" href="pygplates.PolygonOnSphere.html#pygplates.PolygonOnSphere" title="pygplates.PolygonOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolygonOnSphere</span></code></a> <em>polygon</em> using finite rotation <em>fr</em></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">fr</span> <span class="pre">*</span> <span class="pre">great_circle_arc</span></code></p></td>
<td><p>Rotates <a class="reference internal" href="pygplates.GreatCircleArc.html#pygplates.GreatCircleArc" title="pygplates.GreatCircleArc"><code class="xref py py-class docutils literal notranslate"><span class="pre">GreatCircleArc</span></code></a> <em>great_circle_arc</em> using finite rotation <em>fr</em></p></td>
</tr>
</tbody>
</table>
<p>For example, the rotation of a <a class="reference internal" href="pygplates.PolylineOnSphere.html#pygplates.PolylineOnSphere" title="pygplates.PolylineOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolylineOnSphere</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">polyline</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">PolylineOnSphere</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">pole</span><span class="p">,</span> <span class="n">angle</span><span class="p">)</span>
<span class="n">rotated_polyline</span> <span class="o">=</span> <span class="n">finite_rotation</span> <span class="o">*</span> <span class="n">polyline</span>
</pre></div>
</div>
<p>The distance that a point is rotated along its small circle rotation arc can be found using <a class="reference internal" href="#pygplates.FiniteRotation.get_rotation_distance" title="pygplates.FiniteRotation.get_rotation_distance"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_rotation_distance()</span></code></a>.</p>
<p>Two finite rotations can be composed in either of the following equivalent ways:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">composed_finite_rotation</span> <span class="pre">=</span> <span class="pre">finite_rotation1</span> <span class="pre">*</span> <span class="pre">finite_rotation2</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">composed_finite_rotation</span> <span class="pre">=</span> <span class="pre">pygplates.FiniteRotation.compose(finite_rotation1,</span> <span class="pre">finite_rotation2)</span></code></p></li>
</ul>
<p>The latter technique uses <a class="reference internal" href="#pygplates.FiniteRotation.compose" title="pygplates.FiniteRotation.compose"><code class="xref py py-meth docutils literal notranslate"><span class="pre">compose()</span></code></a>. Note that rotation composition is <em>not</em> commutative (<span class="math notranslate nohighlight">\(A \times B \neq B \times A\)</span>).</p>
<p>The reverse, or inverse, of a finite rotation can be found using <a class="reference internal" href="#pygplates.FiniteRotation.get_inverse" title="pygplates.FiniteRotation.get_inverse"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_inverse()</span></code></a>.</p>
<p>Two finite rotations can be interpolated using <a class="reference internal" href="#pygplates.FiniteRotation.interpolate" title="pygplates.FiniteRotation.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interpolated_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">finite_rotation1</span><span class="p">,</span> <span class="n">finite_rotation2</span><span class="p">,</span> <span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">,</span> <span class="n">target_time</span><span class="p">)</span>
</pre></div>
</div>
<p>Finite rotations are equality (<code class="docutils literal notranslate"><span class="pre">==</span></code>, <code class="docutils literal notranslate"><span class="pre">!=</span></code>) comparable (but not hashable - cannot be used as a key in a <code class="docutils literal notranslate"><span class="pre">dict</span></code>).</p>
<p>Finite rotations can also be compared using <a class="reference internal" href="#pygplates.FiniteRotation.are_equivalent" title="pygplates.FiniteRotation.are_equivalent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">are_equivalent()</span></code></a> to detect equivalent rotations (that rotate a geometry to the same final position but might rotate in opposite directions around the globe). A finite rotation can be tested to see if it is an <a class="reference internal" href="#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">identity</span></code></a> rotation (no rotation).</p>
<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">...</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.__init__" title="Permalink to this definition"></a></dt>
<dd><p>A <em>FiniteRotation</em> object can be constructed in more than one way…</p>
<dl>
<dt>__init__(pole, angle_radians)</dt><dd><p>Create a finite rotation from an Euler pole and a rotation angle (in <em>radians</em>).</p>
<dl class="field-list simple">
<dt class="field-odd">param pole</dt>
<dd class="field-odd"><p>the Euler pole.</p>
</dd>
<dt class="field-even">type pole</dt>
<dd class="field-even"><p><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)</p>
</dd>
<dt class="field-odd">param angle_radians</dt>
<dd class="field-odd"><p>the rotation angle (in <em>radians</em>).</p>
</dd>
<dt class="field-even">type angle_radians</dt>
<dd class="field-even"><p>float</p>
</dd>
<dt class="field-odd">raises</dt>
<dd class="field-odd"><p>InvalidLatLonError if <em>latitude</em> or <em>longitude</em> is invalid</p>
</dd>
<dt class="field-even">raises</dt>
<dd class="field-even"><p>ViolatedUnitVectorInvariantError if (x,y,z) is not unit magnitude</p>
</dd>
</dl>
<p>The following example shows a few different ways to use this method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">PointOnSphere</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="n">angle_radians</span><span class="p">)</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_degrees</span><span class="p">))</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">],</span> <span class="n">angle_radians</span><span class="p">)</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">]),</span> <span class="n">angle_radians</span><span class="p">)</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">pygplates</span><span class="o">.</span><span class="n">LatLonPoint</span><span class="p">(</span><span class="n">latitude</span><span class="p">,</span><span class="n">longitude</span><span class="p">),</span> <span class="n">angle_radians</span><span class="p">)</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">((</span><span class="n">latitude</span><span class="p">,</span><span class="n">longitude</span><span class="p">),</span> <span class="n">angle_radians</span><span class="p">)</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">([</span><span class="n">latitude</span><span class="p">,</span><span class="n">longitude</span><span class="p">],</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle_degrees</span><span class="p">))</span>
<span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">numpy</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">latitude</span><span class="p">,</span><span class="n">longitude</span><span class="p">]),</span> <span class="n">angle_radians</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>__init__(from_point, to_point)</dt><dd><p>Create a finite rotation that rotates one point to another along the great circle arc connecting them.</p>
<dl class="field-list simple">
<dt class="field-odd">param from_point</dt>
<dd class="field-odd"><p>the point to rotate <em>from</em></p>
</dd>
<dt class="field-even">type from_point</dt>
<dd class="field-even"><p><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)</p>
</dd>
<dt class="field-odd">param to_point</dt>
<dd class="field-odd"><p>the point to rotate <em>to</em></p>
</dd>
<dt class="field-even">type to_point</dt>
<dd class="field-even"><p><a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)</p>
</dd>
<dt class="field-odd">raises</dt>
<dd class="field-odd"><p>InvalidLatLonError if <em>latitude</em> or <em>longitude</em> is invalid</p>
</dd>
<dt class="field-even">raises</dt>
<dd class="field-even"><p>ViolatedUnitVectorInvariantError if (x,y,z) is not unit magnitude</p>
</dd>
</dl>
<p>If <em>from_point</em> and <em>to_point</em> are the same or antipodal (opposite sides of globe) then an arbitrary rotation axis (among the infinite possible choices) is selected.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">from_point</span><span class="p">,</span> <span class="n">to_point</span><span class="p">)</span>
<span class="c1"># assert(to_point == finite_rotation * from_point)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#pygplates.FiniteRotation.create_great_circle_point_rotation" title="pygplates.FiniteRotation.create_great_circle_point_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_great_circle_point_rotation()</span></code></a></p>
</div>
</dd>
<dt>__init__()</dt><dd><p>Creates a finite rotation that does not rotate (it maps a vector onto the same vector).</p>
<p>Equivalent to <a class="reference internal" href="#pygplates.FiniteRotation.create_identity_rotation" title="pygplates.FiniteRotation.create_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">create_identity_rotation()</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">identity_finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">()</span>
</pre></div>
</div>
</dd>
</dl>
</dd></dl>

<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.__init__" title="pygplates.FiniteRotation.__init__"><code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code></a>(...)</p></td>
<td><p>A <em>FiniteRotation</em> object can be constructed in more than one way...</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.are_equal" title="pygplates.FiniteRotation.are_equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_equal</span></code></a>(finite_rotation1, ...)</p></td>
<td><p>[<em>staticmethod</em>] Return whether two finite rotations have equal pole latitude, longitude and angle to within a threshold in degrees.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.are_equivalent" title="pygplates.FiniteRotation.are_equivalent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">are_equivalent</span></code></a>(finite_rotation1, ...)</p></td>
<td><p>[<em>staticmethod</em>] Return whether two finite rotations represent equivalent rotations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.compose" title="pygplates.FiniteRotation.compose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">compose</span></code></a>(finite_rotation1, finite_rotation2)</p></td>
<td><p>[<em>staticmethod</em>] Composes two finite rotations and returns the composed finite rotation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.create_great_circle_point_rotation" title="pygplates.FiniteRotation.create_great_circle_point_rotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_great_circle_point_rotation</span></code></a>(...)</p></td>
<td><p>[<em>staticmethod</em>] Create a finite rotation that rotates one point to another along the great circle arc connecting them.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.create_identity_rotation" title="pygplates.FiniteRotation.create_identity_rotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_identity_rotation</span></code></a>()</p></td>
<td><p>[<em>staticmethod</em>] Creates a finite rotation that does not rotate (it maps a vector onto the same vector).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.create_segment_rotation" title="pygplates.FiniteRotation.create_segment_rotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_segment_rotation</span></code></a>(from_segment_start, ...)</p></td>
<td><p>[<em>staticmethod</em>] Create a finite rotation that rotates the <em>from</em> line segment to the <em>to</em> line segment.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.create_small_circle_point_rotation" title="pygplates.FiniteRotation.create_small_circle_point_rotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_small_circle_point_rotation</span></code></a>(...)</p></td>
<td><p>[<em>staticmethod</em>] Create a finite rotation, using the specified rotation pole, that rotates <em>from_point</em> to <em>to_point</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.get_euler_pole_and_angle" title="pygplates.FiniteRotation.get_euler_pole_and_angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_euler_pole_and_angle</span></code></a>(...)</p></td>
<td><p>Return the (pole, angle) representing finite rotation.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.get_inverse" title="pygplates.FiniteRotation.get_inverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_inverse</span></code></a>()</p></td>
<td><p>Return the inverse of this finite rotation.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees" title="pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_lat_lon_euler_pole_and_angle_degrees</span></code></a>(...)</p></td>
<td><p>Return the finite rotation as a tuple of pole latitude, pole longitude and  angle (all in degrees).</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.get_rotation_distance" title="pygplates.FiniteRotation.get_rotation_distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_rotation_distance</span></code></a>(point)</p></td>
<td><p>Return the distance that a point rotates along its small circle rotation arc (in radians).</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.interpolate" title="pygplates.FiniteRotation.interpolate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">interpolate</span></code></a>(finite_rotation1, ...)</p></td>
<td><p>[<em>staticmethod</em>] Calculate the finite rotation which is the interpolation of two finite rotations.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-obj docutils literal notranslate"><span class="pre">represents_identity_rotation</span></code></a>()</p></td>
<td><p>Return whether this finite rotation represents an identity rotation (a rotation which maps a vector onto the same vector).</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.are_equal">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">are_equal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">finite_rotation1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">finite_rotation2</span></span></em><span class="optional">[</span>, <em class="sig-param"><span class="n"><span class="pre">threshold_degrees</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.are_equal" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Return whether two finite rotations have equal pole latitude, longitude and angle to within a threshold in degrees.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>finite_rotation1</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the first finite rotation</p></li>
<li><p><strong>finite_rotation2</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the second finite rotation</p></li>
<li><p><strong>threshold_degrees</strong> (<em>float</em>) – optional closeness threshold in degrees</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p>If <em>threshold_degrees</em> is <em>not</em> specified then this function is the same as equality comparison (<code class="docutils literal notranslate"><span class="pre">==</span></code>).</p>
<p>If <em>threshold_degrees</em> is specified then <em>finite_rotation1</em> and <em>finite_rotation2</em> compare equal if both pole latitudes and both pole longitudes and both angles are within <em>threshold_degrees</em> degrees of each other.</p>
<p>Using a threshold in latitude/longitude coordinates is subject to longitude compression at the North and South poles. However these coordinates are useful when comparing finite rotations loaded from a text file that stores rotations using these coordinates (such as PLATES rotation format) and that typically stores values with limited precision.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Are two finite rotations equal to within 0.01 degrees.</span>
<span class="c1"># This is useful when the rotations were loaded from a PLATES rotation file</span>
<span class="c1"># that stored rotation lat/lon/angle to 2 decimal places accuracy.</span>
<span class="k">if</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">are_equal</span><span class="p">(</span><span class="n">finite_rotation1</span><span class="p">,</span> <span class="n">finite_rotation2</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">):</span>
    <span class="o">....</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.are_equivalent">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">are_equivalent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">finite_rotation1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">finite_rotation2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.are_equivalent" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Return whether two finite rotations represent equivalent rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>finite_rotation1</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the first finite rotation</p></li>
<li><p><strong>finite_rotation2</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the second finite rotation</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
<p>Two rotations are equivalent if they rotate a geometry to the same final location. This includes rotating in opposite directions around the globe.</p>
<p>Some examples of equivalent rotations:</p>
<ol class="arabic simple">
<li><p>Negating a finite rotation’s Euler pole (making it antipodal) and negating its angle.</p></li>
<li><p>Negating a finite rotation’s Euler pole (making it antipodal) and setting its angle to ‘360 - angle’ degrees (making the rotation go the other way around the globe).</p></li>
<li><p>Setting a finite rotation’s angle to ‘angle - 360’ degrees (making the rotation go the other way around the globe).</p></li>
</ol>
<p>Note that in (1) the finite rotations also compare equal (<code class="docutils literal notranslate"><span class="pre">==</span></code>), even though they were created with a different pole/angle, whereas in (2) and (3) the finite rotations compare unequal (<code class="docutils literal notranslate"><span class="pre">!=</span></code>). This is because (1) generates the exact same rotation whereas (2) and (3) generate rotations that go the opposite direction around the globe. Note however that all three rotations are still <em>equivalent</em>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">if</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">are_equivalent</span><span class="p">(</span><span class="n">finite_rotation1</span><span class="p">,</span> <span class="n">finite_rotation2</span><span class="p">):</span>
    <span class="o">....</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.compose">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">compose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">finite_rotation1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">finite_rotation2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.compose" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Composes two finite rotations and returns the composed finite rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>finite_rotation1</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the left-hand-side finite rotation</p></li>
<li><p><strong>finite_rotation2</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the right-hand-side finite rotation</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a></p>
</dd>
</dl>
<p>This method does the same as <code class="docutils literal notranslate"><span class="pre">finite_rotation1</span> <span class="pre">*</span> <span class="pre">finite_rotation2</span></code>.</p>
<p>See <a class="reference internal" href="../pygplates_foundations.html#pygplates-foundations-working-with-finite-rotations"><span class="std std-ref">Working with finite rotations</span></a> for more details on composing finite rotations.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">composed_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">compose</span><span class="p">(</span><span class="n">finite_rotation1</span><span class="p">,</span> <span class="n">finite_rotation2</span><span class="p">)</span>
<span class="c1">#...or...</span>
<span class="n">composed_rotation</span> <span class="o">=</span> <span class="n">finite_rotation1</span> <span class="o">*</span> <span class="n">finite_rotation2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.create_great_circle_point_rotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_great_circle_point_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.create_great_circle_point_rotation" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Create a finite rotation that rotates one point to another along the great circle arc connecting them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_point</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the point to rotate <em>from</em></p></li>
<li><p><strong>to_point</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the point to rotate <em>to</em></p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>InvalidLatLonError if <em>latitude</em> or <em>longitude</em> is invalid</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>ViolatedUnitVectorInvariantError if (x,y,z) is not unit magnitude</p>
</dd>
</dl>
<p>If <em>from_point</em> and <em>to_point</em> are the same or antipodal (opposite sides of globe) then an arbitrary rotation axis (among the infinite possible choices) is selected.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">create_great_circle_point_rotation</span><span class="p">(</span><span class="n">from_point</span><span class="p">,</span> <span class="n">to_point</span><span class="p">)</span>
<span class="c1"># assert(to_point == finite_rotation * from_point)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.29.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.create_identity_rotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_identity_rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.create_identity_rotation" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Creates a finite rotation that does not rotate (it maps a vector onto the same vector).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a></p>
</dd>
</dl>
<p>To determine if a finite rotation is an identity rotation use <a class="reference internal" href="#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">represents_identity_rotation()</span></code></a>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">identity_finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">create_identity_rotation</span><span class="p">()</span>
<span class="c1"># assert(identity_finite_rotation.represents_identity_rotation())</span>

<span class="c1"># The rotated point and original point are at the same position.</span>
<span class="n">rotated_point</span> <span class="o">=</span> <span class="n">identity_finite_rotation</span> <span class="o">*</span> <span class="n">point</span>
</pre></div>
</div>
<p>An alternative way to create an identity rotation is with <em>any</em> Euler pole and a <em>zero</em> angle:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">identity_finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">any_euler_pole</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.create_segment_rotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_segment_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_segment_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_segment_end</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_segment_start</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_segment_end</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.create_segment_rotation" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Create a finite rotation that rotates the <em>from</em> line segment to the <em>to</em> line segment.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>from_segment_start</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the start point of the segment to rotate <em>from</em></p></li>
<li><p><strong>from_segment_end</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the end point of the segment to rotate <em>from</em></p></li>
<li><p><strong>to_segment_start</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the start point of the segment to rotate <em>to</em></p></li>
<li><p><strong>to_segment_end</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the end point of the segment to rotate <em>to</em></p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>InvalidLatLonError if <em>latitude</em> or <em>longitude</em> is invalid</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>ViolatedUnitVectorInvariantError if (x,y,z) is not unit magnitude</p>
</dd>
</dl>
<p>This is useful if you have the same geometry but at two different positions/orientations on the globe and you want to determine the rotation that maps one onto the other. In this case you can choose two non-coincident points of the geometry (at two different positions/orientations) and pass those four points to this function. For example, you might have a geometry that’s been reconstructed to two different times but you don’t have those two reconstruction rotations (you only have the two reconstructed geometries) - you can then use this function to find the rotation from one reconstruction time to the other.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">create_segment_rotation</span><span class="p">(</span>
    <span class="n">from_segment_start</span><span class="p">,</span> <span class="n">from_segment_end</span><span class="p">,</span>
    <span class="n">to_segment_start</span><span class="p">,</span> <span class="n">to_segment_end</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <em>from</em> and <em>to</em> segments do not actually have to be the same (arc) length. In this case, while <em>from_segment_start</em> is always rotated onto <em>to_segment_start</em>, <em>from_segment_end</em> is not rotated onto <em>to_segment_end</em>. Instead <em>from_segment_end</em> is rotated such that it is on the great circle containing the <em>to</em> segment. In this way the <em>from</em> segment is rotated such that its orientation matches the <em>to</em> segment (as well as having matching start points).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If either segment is zero length then the returned rotation reduces to one that rotates <em>from_segment_start</em> to <em>to_segment_start</em> along the great circle arc between those two points. This is because one (or both) segments has no orientation (so all we can match are the start points).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It’s fine for the start points of both <em>from</em> and <em>to</em> segments to coincide (and it’s also fine for the end points of both segments to coincide for that matter).</p>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.29.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.create_small_circle_point_rotation">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">create_small_circle_point_rotation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation_pole</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">from_point</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.create_small_circle_point_rotation" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Create a finite rotation, using the specified rotation pole, that rotates <em>from_point</em> to <em>to_point</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotation_pole</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the rotation pole to rotate around</p></li>
<li><p><strong>from_point</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the point to rotate <em>from</em></p></li>
<li><p><strong>to_point</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the point to rotate <em>to</em></p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>InvalidLatLonError if <em>latitude</em> or <em>longitude</em> is invalid</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>ViolatedUnitVectorInvariantError if (x,y,z) is not unit magnitude</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>from_point</em> doesn’t actually have to rotate onto <em>to_point</em>. Imagine <em>rotation_pole</em> is the North Pole, then the returned rotation will rotate such that the longitude matches but not necessarily the latitude.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If either <em>from_point</em> or <em>to_point</em> coincides with <em>rotation_pole</em> then the identity rotation is returned.</p>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">create_small_circle_point_rotation</span><span class="p">(</span><span class="n">rotation_pole</span><span class="p">,</span> <span class="n">from_point</span><span class="p">,</span> <span class="n">to_point</span><span class="p">)</span>
</pre></div>
</div>
<div class="versionadded">
<p><span class="versionmodified added">New in version 0.29.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.get_euler_pole_and_angle">
<span class="sig-name descname"><span class="pre">get_euler_pole_and_angle</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">use_north_pole_for_identity=True</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.get_euler_pole_and_angle" title="Permalink to this definition"></a></dt>
<dd><p>Return the (pole, angle) representing finite rotation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned angle is in <em>radians</em>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>use_north_pole_for_identity</strong> (<em>bool</em>) – whether to return the north pole axis (and zero angle) for an <a class="reference internal" href="#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">identity</span> <span class="pre">rotation</span></code></a> or raise IndeterminateResultError (default is to return north pole axis)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the tuple of (pole, angle_radians)</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a>, float)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>IndeterminateResultError if <em>use_north_pole_for_identity</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and this finite rotation represents the identity rotation</p>
</dd>
</dl>
<p>If <a class="reference internal" href="#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">represents_identity_rotation()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> then this method will return the north pole axis (and zero angle) if <em>use_north_pole_for_identity</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, otherwise <em>IndeterminateResultError</em> is raised.</p>
<p>Alternatively <a class="reference internal" href="#pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees" title="pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_lat_lon_euler_pole_and_angle_degrees()</span></code></a> can be used to return the euler pole as latitude/longitude and angle (all in degrees).</p>
<p>Note that (pole, angle) and (-pole, -angle) represent equivalent rotations (see <a class="reference internal" href="#pygplates.FiniteRotation.are_equivalent" title="pygplates.FiniteRotation.are_equivalent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">are_equivalent()</span></code></a>) and either could be returned. However, if this finite rotation was created with <em>__init__(pole, angle)</em> then the same pole and angle will be returned here.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">pole</span><span class="p">,</span> <span class="n">angle_radians</span><span class="p">)</span>
<span class="n">pole</span><span class="p">,</span> <span class="n">angle_radians</span> <span class="o">=</span> <span class="n">finite_rotation</span><span class="o">.</span><span class="n">get_euler_pole_and_angle</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.get_inverse">
<span class="sig-name descname"><span class="pre">get_inverse</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.get_inverse" title="Permalink to this definition"></a></dt>
<dd><p>Return the inverse of this finite rotation.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a></p>
</dd>
</dl>
<p>The inverse represents the reverse rotation as the following code demonstrates:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rotated_point</span> <span class="o">=</span> <span class="n">finite_rotation</span> <span class="o">*</span> <span class="n">point</span>
<span class="n">original_point</span> <span class="o">=</span> <span class="n">finite_rotation</span><span class="o">.</span><span class="n">get_inverse</span><span class="p">()</span> <span class="o">*</span> <span class="n">rotated_point</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees">
<span class="sig-name descname"><span class="pre">get_lat_lon_euler_pole_and_angle_degrees</span></span><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="n"><span class="pre">use_north_pole_for_identity=True</span></span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.get_lat_lon_euler_pole_and_angle_degrees" title="Permalink to this definition"></a></dt>
<dd><p>Return the finite rotation as a tuple of pole latitude, pole longitude and  angle (all in degrees).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The returned angle is in <em>degrees</em> (as are the latitude and longitude).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>use_north_pole_for_identity</strong> (<em>bool</em>) – whether to return the north pole axis (and zero angle) for an <a class="reference internal" href="#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">identity</span> <span class="pre">rotation</span></code></a> or raise IndeterminateResultError (default is to return north pole axis)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>the tuple of (pole_latitude, pole_longitude, angle_degrees) all in <em>degrees</em></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple (float, float, float)</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p>IndeterminateResultError if <em>use_north_pole_for_identity</em> is <code class="docutils literal notranslate"><span class="pre">False</span></code> and this finite rotation represents the identity rotation</p>
</dd>
</dl>
<p>If <a class="reference internal" href="#pygplates.FiniteRotation.represents_identity_rotation" title="pygplates.FiniteRotation.represents_identity_rotation"><code class="xref py py-meth docutils literal notranslate"><span class="pre">represents_identity_rotation()</span></code></a> returns <code class="docutils literal notranslate"><span class="pre">True</span></code> then this method will return the north pole axis (and zero angle) if <em>use_north_pole_for_identity</em> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, otherwise <em>IndeterminateResultError</em> is raised.</p>
<p>Note that (latitude, longitude, angle) and (-latitude, longitude-180, -angle) represent equivalent rotations (see <a class="reference internal" href="#pygplates.FiniteRotation.are_equivalent" title="pygplates.FiniteRotation.are_equivalent"><code class="xref py py-meth docutils literal notranslate"><span class="pre">are_equivalent()</span></code></a>) and either could be returned. However, if this finite rotation was created with <em>__init__(pole, angle)</em> then the same pole and angle will be returned here.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">pole</span><span class="p">,</span> <span class="n">angle_radians</span><span class="p">)</span>
<span class="n">pole_latitude</span><span class="p">,</span> <span class="n">pole_longitude</span><span class="p">,</span> <span class="n">angle_degrees</span> <span class="o">=</span> <span class="n">finite_rotation</span><span class="o">.</span><span class="n">get_lat_lon_euler_pole_and_angle_degrees</span><span class="p">()</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.get_rotation_distance">
<span class="sig-name descname"><span class="pre">get_rotation_distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">point</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.get_rotation_distance" title="Permalink to this definition"></a></dt>
<dd><p>Return the distance that a point rotates along its small circle rotation arc (in radians).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>point</strong> (<a class="reference internal" href="pygplates.PointOnSphere.html#pygplates.PointOnSphere" title="pygplates.PointOnSphere"><code class="xref py py-class docutils literal notranslate"><span class="pre">PointOnSphere</span></code></a> or <a class="reference internal" href="pygplates.LatLonPoint.html#pygplates.LatLonPoint" title="pygplates.LatLonPoint"><code class="xref py py-class docutils literal notranslate"><span class="pre">LatLonPoint</span></code></a> or tuple (latitude,longitude), in degrees, or tuple (x,y,z)) – the point being rotated (the start point of the rotation arc)</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
<p>Returns the distance along the (small circle) rotation arc from the start point <em>point</em> to the end point <code class="docutils literal notranslate"><span class="pre">finite_rotation</span> <span class="pre">*</span> <span class="pre">point</span></code>. Note that the returned distance is not the angle of rotation - it is the actual distance on the unit radius sphere (hence radians). To convert to distance on the Earth’s surface multiply by the Earth radius (see <a class="reference internal" href="pygplates.Earth.html#pygplates.Earth" title="pygplates.Earth"><code class="xref py py-class docutils literal notranslate"><span class="pre">Earth</span></code></a>).</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">rotated_distance_radians</span> <span class="o">=</span> <span class="n">finite_rotation</span><span class="o">.</span><span class="n">get_rotation_distance</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.interpolate">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">interpolate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">finite_rotation1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">finite_rotation2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_time</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.interpolate" title="Permalink to this definition"></a></dt>
<dd><p>[<em>staticmethod</em>] Calculate the finite rotation which is the interpolation of two finite rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>finite_rotation1</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the left-hand-side finite rotation</p></li>
<li><p><strong>finite_rotation2</strong> (<a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a>) – the right-hand-side finite rotation</p></li>
<li><p><strong>time1</strong> (float or <a class="reference internal" href="pygplates.GeoTimeInstant.html#pygplates.GeoTimeInstant" title="pygplates.GeoTimeInstant"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeoTimeInstant</span></code></a>) – the time associated with the left-hand-side finite rotation</p></li>
<li><p><strong>time2</strong> (float or <a class="reference internal" href="pygplates.GeoTimeInstant.html#pygplates.GeoTimeInstant" title="pygplates.GeoTimeInstant"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeoTimeInstant</span></code></a>) – the time associated with the right-hand-side finite rotation</p></li>
<li><p><strong>target_time</strong> (float or <a class="reference internal" href="pygplates.GeoTimeInstant.html#pygplates.GeoTimeInstant" title="pygplates.GeoTimeInstant"><code class="xref py py-class docutils literal notranslate"><span class="pre">GeoTimeInstant</span></code></a>) – the time associated with the result of the interpolation</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#pygplates.FiniteRotation" title="pygplates.FiniteRotation"><code class="xref py py-class docutils literal notranslate"><span class="pre">FiniteRotation</span></code></a></p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p>InterpolationError if any time value is <a class="reference internal" href="pygplates.GeoTimeInstant.html#pygplates.GeoTimeInstant.is_distant_past" title="pygplates.GeoTimeInstant.is_distant_past"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distant</span> <span class="pre">past</span></code></a> or <a class="reference internal" href="pygplates.GeoTimeInstant.html#pygplates.GeoTimeInstant.is_distant_future" title="pygplates.GeoTimeInstant.is_distant_future"><code class="xref py py-meth docutils literal notranslate"><span class="pre">distant</span> <span class="pre">future</span></code></a></p>
</dd>
</dl>
<p>The finite rotations <em>finite_rotation1</em> and <em>finite_rotation2</em> are associated with times <em>time1</em> and <em>time2</em>, respectively. The result of the interpolation is associated with <em>target_time</em>. The interpolated finite rotation is generated using Spherical Linear intERPolation (SLERP) with the interpolation factor <code class="docutils literal notranslate"><span class="pre">(target_time</span> <span class="pre">-</span> <span class="pre">time1)</span> <span class="pre">/</span> <span class="pre">(time2</span> <span class="pre">-</span> <span class="pre">time1)</span></code>.</p>
<p><em>target_time</em> can be any time - it does not have to be between <em>time1</em> and <em>time2</em>.</p>
<p>If <em>time1</em> and <em>time2</em> are equal then <em>finite_rotation1</em> is returned.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">interpolated_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">finite_rotation1</span><span class="p">,</span> <span class="n">finite_rotation2</span><span class="p">,</span> <span class="n">time1</span><span class="p">,</span> <span class="n">time2</span><span class="p">,</span> <span class="n">target_time</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pygplates.FiniteRotation.represents_identity_rotation">
<span class="sig-name descname"><span class="pre">represents_identity_rotation</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pygplates.FiniteRotation.represents_identity_rotation" title="Permalink to this definition"></a></dt>
<dd><p>Return whether this finite rotation represents an identity rotation (a rotation which maps a vector onto the same vector).</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create an identity rotation using zero angle and any pole location.</span>
<span class="n">identity_finite_rotation</span> <span class="o">=</span> <span class="n">pygplates</span><span class="o">.</span><span class="n">FiniteRotation</span><span class="p">(</span><span class="n">any_pole</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="c1"># assert(identity_finite_rotation.represents_identity_rotation())</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="pygplates.RotationModel.html" class="btn btn-neutral float-left" title="pygplates.RotationModel" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="pygplates.ReconstructionTree.html" class="btn btn-neutral float-right" title="pygplates.ReconstructionTree" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright (C) 2003-2022 The University of Sydney, Australia
(C) 2004-2022 California Institute of Technology
(C) 2007-2022 The Geological Survey of Norway
.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>